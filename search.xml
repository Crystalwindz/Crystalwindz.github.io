<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Go学习笔记</title>
      <link href="/go_study_note/"/>
      <url>/go_study_note/</url>
      
        <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>for是Go中的while；</li><li>if可以在判断之前执行一条语句；</li><li>switch自动break，case无需为整数；</li><li>切片的cap就是切片能扩展的最大长度；</li><li>指针不能运算；</li><li>类型和函数不用先声明就能用；</li><li>Go里面没有隐式类型提升；</li><li>类型定义和类型方法必须在同一个包内；</li><li>.(type)类型选择必须和switch一起结合使用（泛型编程？）；</li><li><strong>无论是指针还是值，都可以直接通过 . 访问成员，Go自动(*p).x</strong>；</li><li><strong>类型方法也是，无论接受指针还是值，指针和值都可以直接调用，Go自动(*p).foo()或(&amp;a).foo()，这时的指针接受者可以理解为C++里的引用</strong>；</li><li>每定义一个常量，iota就递增1，iota从0开始；</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li><strong>接口指针永远无法满足接口</strong>；</li><li><strong>接口里存的永远是变量的具体类型，绝不可能是另一个接口类型，因此可以把接口类型和其他类型看做两种类型，接口是用来存其他类型的</strong>；</li><li><strong>实现接口时如果是指针类型，那么就只有类型指针满足接口，毕竟指针接口会更改原值</strong>；</li><li><strong>但实现接口时如果是值类型，那么类型和类型指针都满足接口，这时只需要传一个拷贝，那么是不是指针就无所谓了</strong>；</li><li>空接口interface{}可保存任意值；</li><li>接口类型可以内嵌其他接口，相当于把其他接口方法写在这里；</li></ul><a id="more"></a><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul><li>Go中函数形参都是传值的；</li><li>slice、map、chan是引用类型；</li><li>nil指针是可以调用方法的，不会导致空指针异常，毕竟没有解引用（C++里是因为要先解引用才能调用成员函数，换句话说就是this指针不能为空）；</li><li>但nil指针是不能访问成员的，这会导致解引用空指针SIGSEGV；</li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>Go是静态编译的；</li><li>go install和go build的区别：从go help来看，go build会编译main包并将bin文件写到当前目录，如果编译的文件不是main包或是多个包，bulid只检查这些文件是否可编译，并不生成文件，并且build会忽略*_test.go文件，但在只编译一个包时可以指定-o强制build生成文件；go install会把二进制文件放在bin文件夹里，*.a文件放在pkg文件夹里；</li></ul><h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><ul><li><strong>信道上的发送操作总在对应的接收操作完成前发生</strong>；</li><li><strong>从无缓冲信道进行的接收，要发生在对该信道进行的发送完成之前</strong>；</li><li><strong>再解释一下上面两点，如果读一个ch，只有另一个go程对ch写了，读才能返回；如果写一个无缓冲ch，只有另一个go程对ch读了，写才能返回</strong>；</li><li><strong>就算r1监测到了w1，也不意味着r1之后的r2能检测到w0（应该是因为编译器调换了w之间的位置？）</strong>；</li><li><strong>nil chan永远不会准备好通信</strong>，这可以用在select里；</li><li>chan通过放置&lt;-的位置决定chan是只读还是只写还是双向；</li><li>Go程没有返回值，惯例是传入一个chan，通过这个chan发送返回值；</li></ul><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul><li>map不是线程安全的，不过Go1.9里新加了sync.Map；</li><li>容量为0的map和nil map是两个东西，nil map是不能添加元素的；</li></ul><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><ul><li>闭包和Go程一起使用时，当心<strong>不要让Go程共享一个变量</strong>，请传一个拷贝进去；</li><li><strong>string类型是不可变的</strong>，因此取s[i]的地址也是非法的；</li><li>接口内嵌和type alias时注意不要递归循环引用；</li><li>defer关闭句柄请按参数传入，函数体内直接用的话是引用，可能会在defer函数执行前被更改；</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>函数的最后一个参数如果是…T，这相当于[]T，说明可以用T类型的零个(nil)或多个参数调用函数；</li><li><strong>make([]int, 50, 100)和new([100]int)[0:50]是等价的</strong>；</li><li>type alias(Go 1.9)：使用type关键字时，如果是type A = int，那么A就是int的别名，这和type B int，定义了一个新类型B不一样；</li><li>假如有这样一个函数 func (t T) Foo(a int) int {}，那么T.Foo就是 func(t T, a int) int 这样一个函数，类似的如果是指针的话，就要(<em>T).Foo这样写，产生一个 func(t </em>T, a int) int 函数；</li></ul><h2 id="defer相关"><a href="#defer相关" class="headerlink" title="defer相关"></a>defer相关</h2><ul><li><a href="https://blog.csdn.net/Tybyqi/article/details/83827140" target="_blank" rel="noopener">defer实现原理剖析，写的相当不错</a></li><li>defer调用的函数的参数在defer语句时就已经确定；</li><li>defer后进先出；</li><li><strong>如果一个函数有命名返回值的话，那么在defer函数里是可以更改这个返回值的</strong>；</li><li>For instance, if the deferred function is a function literal and the surrounding function has named result parameters that are in scope within the literal, the deferred function may access and modify the result parameters before they are returned. If the deferred function has any return values, they are discarded when the function completes.</li></ul><h2 id="Effective-Go"><a href="#Effective-Go" class="headerlink" title="Effective Go"></a>Effective Go</h2><ul><li>只包含一个方法的接口以方法名加er命名；</li><li>可以返回局部变量的地址；</li><li>每当获取一个复合字面的地址时，都将为一个新的实例分配内存；</li><li>new和make：new分配一块内存并将内存<strong>置零</strong>，返回其指针；make只用于创建三种引用类型——slice、map、channel——并对其进行初始化；</li><li>实现Stringer接口当心递归；</li><li>func init()在main前设置一些初始状态，也可以检查一些东西；</li><li>如果一个类型只实现了一个接口，没有其他导出的方法，那么应该只导出这个接口，这能让代码更通用；</li><li>通过通信共享内存；</li><li>使用Context时，把它放在函数的第一个参数；</li><li>从其他包拷贝结构体时当心拷贝其内部的引用(切片等)；</li><li>var t []string 与 t:=[]string{}，前者是nil切片，后者是non-nil空切片，注意区分；</li><li>使用crypto/rand生成密钥；</li><li>error string应该是小写的一个短语，因为它通常用在别的句子里；</li><li>尽可能控制Go程生命周期；</li><li>分组import；</li><li>. import通常只在test中有用；</li><li>函数返回错误应该是最后一个返回值；</li><li><p>处理错误流请这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x, err := foo()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use x, normal code</span></span><br></pre></td></tr></table></figure></li><li><p>使用后再定义接口，在接口的使用处定义，而不是接口的实现处；</p></li><li>方法接受者的名字应该是一个简短的缩写，不应该是this, self这种，并且接受者名字请在所有方法中保持一致；</li><li>传值或指针的场景：<ul><li>值：小类型、不需要更改的值、map、func、chan、不变的slice；</li><li>指针：大类型、需要更改的值、包含同步的值、选值或指针都差不多时就选指针；</li></ul></li><li>尽可能使用同步函数；</li><li>变量名尽可能短一点，声明距离使用越远就越应该有描述性；</li></ul><h2 id="The-Go-Programming-Language"><a href="#The-Go-Programming-Language" class="headerlink" title="The Go Programming Language"></a>The Go Programming Language</h2><ul><li>Go不需要加分号，但这不意味着Go没有分号。实际上是由编译器将特定符号后的换行符自动转换为分号的，这也是为什么左大括号必须和函数声明在同一行的原因。另外这也对Go代码换行有一定影响，比如：x + y，必须要在+后换行，在+前换行的话，编译器会在x后面添加分号，然后就编译错误了，参数列表最后可以加逗号也是这个原因；</li><li>map是哈希map，并且是随机哈希，每次range遍历顺序都不一致，这是为了防止利用哈希冲突的DOS攻击；</li><li>对象的(生命周期、分配区域)和(作用域、是否用var或new声明)无关，因为一个变量的生命周期只取决于是否可达，即使是局部变量，也可能因为有外部指针引用了它而逃逸，而就算是new的变量，只要它没逃逸也是可以分配在栈上的；</li><li>内存分配因为有了垃圾回收会好很多，但请考虑生命周期问题，比如不要把指向短生命周期对象的指针放在长生命周期对象中；</li><li>元组赋值，先对右边所有表达式求值，再统一更新左边变量；</li><li>类型转换错误只会发生在编译阶段；</li><li>包在解决依赖的前提下，按导入顺序初始化，每个包只初始化一次；</li><li>对于需要复杂初始化的全局变量，可以将初始化放在init函数中进行，也可以将初始化逻辑包装为一个匿名函数处理；</li><li>作用域是编译时的概念，生命周期是运行时的概念；</li><li><p>当心下面的坑，在这里，内部新声明了cwd变量，而全局cwd并未被正确初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cwd <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cwd, err := os.Getwd() <span class="comment">// <span class="doctag">NOTE:</span> wrong!</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"os.Getwd failed: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Working directory = %s"</span>, cwd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果一个函数返回的浮点数结果可能失败，最好用单独的标志报告失败；</p></li><li>常量可以是无类型的，无类型常量可以提供很高的精度(至少256位)，可以用于更多的表达式而无需显式类型转换；</li><li>slice三部分：指针，长度，容量；</li><li>slice之间不能比较，但可以和nil相比；</li><li>可以用map[T]bool实现集合set类型，对于无法比较的T类型也可以通过辅助函数使其可以比较；</li><li>五种错误处理策略：<ul><li>返回错误给上层；</li><li>检测到错误后，重试失败的操作；</li><li>输出错误并结束程序；</li><li>只打印错误信息；</li><li>忽略错误；</li></ul></li><li>匿名函数需要递归调用时，应先声明变量再将匿名函数赋值给它；</li><li>捕获迭代变量时，注意捕获的是迭代变量的地址，因此应再声明一个局部变量；</li><li>defer可以实现记录何时进入函数和退出函数，也可以打印或修改函数返回值；</li><li>只要命名类型的底层类型不是指针或接口，就可以给这个类型定义方法；</li><li>嵌入结构体可以给匿名类型添加方法；</li><li>编译期断言T类型满足接口I：var _ I = (*T)(nil)；</li><li>注意区分nil接口和包含nil指针的接口；</li><li>http.HandlerFunc(T)是一个类型转换而不是函数调用；</li><li>对nil接口值断言永远会失败；</li><li>happens before:这不是一个时间概念，是一个和内存可见性有关的概念；</li><li>泄露的Go程不会被回收，请确保没有Go程永远阻塞；</li><li>select的一些用法：<ul><li>default可实现非阻塞；</li><li>time.After可实现超时；</li><li>创建一个chan可以实现取消机制；</li><li>关闭一个chan可以实现广播机制；</li></ul></li><li>Go程的栈大小是可变的，且没有ID号；</li><li>导入包的副作用：计算包级变量的初始化表达式和执行导入包的init函数；</li><li>unsafe.Pointer和uintptr的转换是不安全的，可能会因为垃圾回收导致野指针；</li></ul><h2 id="50度灰"><a href="#50度灰" class="headerlink" title="50度灰"></a>50度灰</h2><ul><li><p>向无缓存的Channel发送消息，只要目标接收者准备好就会立即返回；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> m := <span class="keyword">range</span> ch &#123;</span><br><span class="line">            fmt.Println(<span class="string">"processed:"</span>,m)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    ch &lt;- <span class="string">"cmd.1"</span></span><br><span class="line">    ch &lt;- <span class="string">"cmd.2"</span> <span class="comment">//won't be processed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>记得关闭http响应；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    resp, err := http.Get(<span class="string">"https://api.ipify.org?format=json"</span>)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>recover()的调用仅当它在defer函数中被直接调用时才有效；</p></li><li><p>关于for中的迭代变量，想清楚下面的区别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span> <span class="title">print</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []field&#123; &#123;<span class="string">"one"</span>&#125;,&#123;<span class="string">"two"</span>&#125;,&#123;<span class="string">"three"</span>&#125; &#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">//goroutines print: three, three, three</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span> <span class="title">print</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []*field&#123; &#123;<span class="string">"one"</span>&#125;,&#123;<span class="string">"two"</span>&#125;,&#123;<span class="string">"three"</span>&#125; &#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">        <span class="comment">//goroutines print: one, two, three(unordered)</span></span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">3</span> * tecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>defer语句在函数结束时才会执行，因此注意资源问题；</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从一道面试题入手——谈谈socket的关闭</title>
      <link href="/socket_close_detail/"/>
      <url>/socket_close_detail/</url>
      
        <content type="html"><![CDATA[<pre><code>服务器端创建一个socket，然后listen之后sleep，如果在sleep期间，有客户端connect服务器，服务器是否会醒来？或者怎样？</code></pre><p>让我们来做个实验，代码如下(使用windz网络库)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Socket sockfd(socket(AF_INET, SOCK_STREAM, 0));</span><br><span class="line">    sockfd.Bind(InetAddr(<span class="number">2019</span>));</span><br><span class="line">    sockfd.Listen();</span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Socket sockfd(socket(AF_INET, SOCK_STREAM, 0));</span><br><span class="line">    sockfd.Connect(InetAddr(<span class="string">"127.0.0.1"</span>, <span class="number">2019</span>));</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>开两个终端，使用tcpdump抓包和netstat观察状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i lo port 2019</span><br><span class="line">netstat -natp | grep 2019</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/socket_close_detail/1.png" alt=""></p><p><img src="/socket_close_detail/2.png" alt=""></p><p><img src="/socket_close_detail/3.png" alt=""></p><p>以此来看，server并不会被唤醒，并且我们知道，一个进程结束时是会关闭它打开的所有fd的，而这里就是关闭socket，对应的就是前两次挥手，客户 sleep 10s，之后关闭，进行第一次挥手，服务器那边则是因为没有accept，直接发送RST终止连接。如果我们在服务器那边添加accpet的话，结果如下：</p><p><img src="/socket_close_detail/4.png" alt=""></p><p><img src="/socket_close_detail/5.png" alt=""></p><p><img src="/socket_close_detail/6.png" alt=""></p><p><img src="/socket_close_detail/7.png" alt=""></p><p>可看出进行的正常的四次挥手。</p><p>那么这些现象涉及到的底层原理有什么呢，简单总结一下：</p><ul><li><p>全连接队列和半连接队列</p><p>  <img src="/socket_close_detail/8.jpg" alt=""></p><p>  每个listen socket有两个队列，就是全连接队列和半连接队列，server收到client的syn后，把连接信息放入syns queue，并回复SYN+ACK，之后收到ACK就从syns queue中拿出队列放入accept queue。</p></li><li><p>TCP连接的关闭细节</p></li></ul><p><img src="/socket_close_detail/9.jpeg" alt="close"></p><p><img src="/socket_close_detail/10.jpeg" alt="shutdown"></p><p>细节都在上面那两张图了。</p><ul><li><p>其他的需要思考的地方</p><ul><li><p>为何第一次握手的序列号是随机的？</p><ul><li>首先，如果每个TCP连接的序列号都从1开始的话，那么如果某个序列号为1的报文因为网络原因延迟，然后这个报文过了很久，在新的连接中又出现，服务器是无法区分的。对于不同的连接，应该避免这种情况，而对于同一个连接的两个不同实例，这会导致数据混乱，是更加严重的；</li><li>其次，从另一方面来讲，这也是TCP的一个缺陷，如果选择合适的IP地址，端口号，序列号，就可以伪造一个TCP连接中的数据包，进而攻击正常的连接，那么采用随机的初始序列号就能让攻击者难以猜出序列号。</li></ul></li><li><p>关于netstat的输出</p><p>  可以看到Program一列有时候是-，按照前面的分析，可以知道此时这个连接不属于任何进程，这也能一定程度上加深对两个队列的理解：除非你调用accept，否则一个ESTABLISH的连接是不属于任何进程的。</p></li></ul></li></ul><p>参考资料：</p><ol><li><a href="http://www.cnxct.com/something-about-phpfpm-s-backlog/" target="_blank" rel="noopener">TCP SOCKET中backlog参数的用途是什么？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247487779&amp;idx=1&amp;sn=0980243dcec05c5df8e2e60937c2c5ed&amp;chksm=e9292c2cde5ea53a7b309e3575c78940a378b358292a3badb828d6c9bb6e8d3997800564b1d5&amp;mpshare=1&amp;scene=23&amp;srcid=0705cNzStWAzvxd5GzatiiNZ#rd" target="_blank" rel="noopener">TCP 三次握手原理，你真的理解吗？</a></li><li><a href="https://blog.csdn.net/russell_tao/article/details/13092727" target="_blank" rel="noopener">高性能网络编程4–TCP连接的关闭</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>谈谈写windz的收获</title>
      <link href="/windz/"/>
      <url>/windz/</url>
      
        <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/Crystalwindz/windz" target="_blank" rel="noopener">Crystalwindz/windz</a></p><p>经过一个半月的努力，windz库终于写完了。起初只是想做个Web服务器交课设，但这服务器越写越偏，越来越像一个网络库，于是就想，索性就写成网络库吧，都说C++程序员都喜欢造轮子，也许我也是。</p><p>一开始写Web服务器时，我也只是看过APUE、UNP，简单了解网络编程的人，实际写起来C++网络程序，也是相当困难，无从下手。万事开头难嘛，于是尝试在github上找找别人写的Web服务器，阅读源码来学习一下，有幸看到了<a href="https://github.com/linyacool/WebServer" target="_blank" rel="noopener">linyacool/WebServer</a>，readme写的相当详细，并大力推荐了陈硕的<a href="https://github.com/chenshuo/muduo" target="_blank" rel="noopener">chenshuo/muduo</a>和他的<a href="https://book.douban.com/subject/20471211/" target="_blank" rel="noopener">Linux多线程服务端编程</a>，我看到后当即就去学校图书馆借了一本。借来这本书，看到目录和书背上的一些问题，感觉无比痛快，我的疑问大部分都在上面有了详细的解答，上一次看书这么爽还是看Effective C++的时候。</p><p>于是便读了书，跟着书中的指引和源码，一步一步地把windz这个库写完了，通过读书和写这个库，我学到了太多太多：<br><a id="more"></a></p><ul><li>搞懂了Reactor模式：之前看过不少博客讲解Reactor模式，但都一知半解，以后要注意了，想学一些知识，不能只看理论知识，还是要落实到实际代码上去才能彻底搞懂；</li><li>熟悉了多线程编程和锁的使用：通过实际编写多线程的程序，能深刻体会到线程同步的困难和重要；</li><li>对内存控制，RAII理解更加深刻：muduo库中用到了enable_shared_from_this，shared_ptr, unique_ptr, weak_ptr，各种各样的智能指针，就算智能指针大大解决了内存泄露的问题，但实际用起来才会明白，不合理地使用智能指针，一样会造成内存泄漏(循环引用)，空悬指针(必须要严格遵守RAII，千万不要释放裸指针，所以也尽量使用make_shared, make_unique)等问题，至于enable_shared_from_this，想弄懂它的原理，更是要明白智能指针的实现细节——全局引用计数，weak_ptr和shared_ptr共享同一个全局引用计数；</li><li>知道了网络编程的各种细节：学过计算机网络，看过UNP，可到实际编写网络程序时才懂得基础是多么重要，三次握手四次挥手，socket，bind，listen，accept，connect，read，write，IO复用，每个环节都有各种各样要注意的细节，必须要理解每个参数的含义，返回值的含义，才能写出可靠的网络程序；</li><li>理解了代码规范的重要：整个windz总计4500多行，我全程按照Google C++规范编写，并注意了各种命名，头文件的包含顺序等，才能时刻清楚自己在写什么。4500行，感觉只能算是一个小数量的代码，我一个人单独编写，没有项目经验的我，勉强撑住了这次考验，也算是提高了阅读代码的能力。</li><li>熟悉一些工具：git，travis-ci，CMake，gdb，clang-format，CLion等；</li><li>其他的一些收获：踩踩C++本身的坑，学会测试自己的代码，conf文件规范，定时器的编写，熟悉Linux系统调用等。</li></ul><p>整体来说，写windz是处于学习目的，写的仍有很多我没发现的缺陷，仍需努力:(</p><p>以cloc截图结尾吧:)</p><p><img src="/windz/1.png" alt="cloc"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> windz </tag>
            
            <tag> 网络库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis设计与实现-数据库与持久化</title>
      <link href="/redis_db/"/>
      <url>/redis_db/</url>
      
        <content type="html"><![CDATA[<h2 id="键空间"><a href="#键空间" class="headerlink" title="键空间"></a>键空间</h2><p>Redis是一个key-value数据库，RedisServer中有多个数据库，每个数据库都由一个redisDb结构表示，其中的dict字典保存了数据库中所有的键值对，dict称之为键空间：</p><ul><li>key就是数据库的键；</li><li>value就是数据库的值，具体为字符串、列表、哈希、集合、有序集合中的一种；</li></ul><p>假设这是一个现有的键空间：</p><p><img src="/redis_db/1.png" alt=""></p><p>添加键：<br><a id="more"></a><br><img src="/redis_db/2.png" alt=""></p><p>删除键：</p><p><img src="/redis_db/3.png" alt=""></p><p>更新键：</p><p><img src="/redis_db/4.png" alt=""></p><p><img src="/redis_db/5.png" alt=""></p><p>获取键：</p><p><img src="/redis_db/6.png" alt=""></p><p>由于这个键空间包括了几乎所有的数据，很多针对数据库的命令都是对这个键空间进行处理来完成的。</p><h2 id="键过期策略"><a href="#键过期策略" class="headerlink" title="键过期策略"></a>键过期策略</h2><p>和键空间类似，redisDb中的expires字典保存了所有设置了过期时间的键，这个过期字典中存着键的过期时间和键的引用，增删改查和键类似。</p><p>删除策略：</p><ul><li>定时删除：利用定时器，准时删除键，然而对cpu时间不友好，不灵活，redis没有采用；</li><li>惰性删除：当获取一个过期的键时，才删除它，但会浪费内存；</li><li>定期删除：每隔一段时间就检查一遍过期字典，删除过期的键，但不好确定间隔时间；</li></ul><p>Redis采用的后两种删除策略，在cpu时间和内存浪费之间努力平衡。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB将内存数据存储在硬盘上，既可以手动执行，也可以让Redis定期自动执行，持久化的过程如下：</p><ul><li>BGSAVE：fork出一个子进程，然后子进程创建RDB文件，父进程继续处理请求；</li><li>SAVE：阻塞服务进程直至创建RDB文件完成。</li></ul><p>RDB的恢复会阻塞服务进程，直至恢复完成。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF每次执行写命令就将写命令记录下来。具体过程：</p><ul><li>服务器每执行一个写命令，就将这个写命令添加到一个缓冲区里；</li><li>根据设置的时间，定期将缓冲区写入硬盘；</li></ul><p>AOF的恢复会创建一个伪客户端，由这个伪客户端执行保存的写命令来恢复。</p><p>AOF的重写：</p><ul><li>AOF重写可以降低AOF文件的冗余，听起来需要对现有的AOF文件进行处理，实际上根本用不到现有的AOF文件；</li><li>AOF重写会直接读取当前数据库的键空间，根据里面的键值对来生成相应的写命令；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis设计与实现-基本数据结构</title>
      <link href="/redis_learn/"/>
      <url>/redis_learn/</url>
      
        <content type="html"><![CDATA[<h2 id="SDS-简单动态字符串"><a href="#SDS-简单动态字符串" class="headerlink" title="SDS(简单动态字符串)"></a>SDS(简单动态字符串)</h2><p>Redis只使用C字符串作为字面量，其他地方都使用SDS来表示字符串，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单动态字符串</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;   <span class="comment">// buf已用字节数，也是字符串长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;  <span class="comment">// buf未用字节数</span></span><br><span class="line">    <span class="keyword">char</span> buf[];<span class="comment">// 保存字节的数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><img src="/redis_learn/1.png" alt=""></li><li>SDS与C字符串类似，以’\0’结尾，但len不计’\0’的长度；</li><li>SDS和C字符串相比：<ol><li>有了len字段，可以常数时间获得字符串长度；</li><li>有了free字段，可以避免缓冲区溢出；</li><li>可以减少内存重分配的次数：<ol><li>空间预分配：当需要扩展buf空间时，为buf分配额外的空间。修改后的len如果小于1MB，就分配和len相同大小的额外空间，大于1MB则分配1MB的额外空间；</li><li>惰性空间释放：当SDS长度缩短时，并不立刻回收内存，而是先用free记录空闲的空间，当必要时才释放空闲空间；</li></ol></li><li>有了len字段，SDS也是二进制安全的，因为SDS使用len而不是’\0’来判断字符串结束；</li><li>由于SDS以’\0’结尾，所以兼容部分C字符串函数；</li></ol></li><li>总结一下：</li></ul><table><thead><tr><th style="text-align:center">C字符串</th><th style="text-align:center">SDS</th></tr></thead><tbody><tr><td style="text-align:center">获取strlen为O(N)</td><td style="text-align:center">获取strlen为O(1)</td></tr><tr><td style="text-align:center">API不安全，缓冲区可能溢出</td><td style="text-align:center">API安全，缓冲区不会溢出</td></tr><tr><td style="text-align:center">修改字符串N次必然需要N次内存重分配</td><td style="text-align:center">修改字符串N次最多需要N次内存重分配</td></tr><tr><td style="text-align:center">只能保存文本数据</td><td style="text-align:center">可以保存文本或二进制数据</td></tr><tr><td style="text-align:center">可以使用所有\&lt;string.h&gt;函数</td><td style="text-align:center">可以使用部分\&lt;string.h&gt;函数</td></tr></tbody></table><a id="more"></a><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>Redis中链表使用很广泛，除了作为列表键的一种实现，发布与订阅、慢查询、监视器等都用到了链表，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="keyword">void</span> *(*dup) (<span class="keyword">void</span> *ptr);<span class="comment">// 节点复制函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>) (<span class="keyword">void</span> *ptr);<span class="comment">// 节点释放函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match) (<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);<span class="comment">// 节点比较函数</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><ul><li><img src="/redis_learn/2.png" alt=""></li><li>Redis的链表特点：<ul><li>双向链表；</li><li>无环：表头的prev和表尾的next指向NULL；</li><li>表头和表尾；</li><li>表长度计数器；</li><li>多态：listNode用void*保存节点值，然后设置dup, free, match函数即可实现多态；</li></ul></li></ul><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>Redis使用字典作为底层实现，字典也是散列键的实现之一，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key; <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span>     *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span>  s64;</span><br><span class="line">    &#125; v; <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 链地址法解决冲突</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;     <span class="comment">// 哈希表数组</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;    <span class="comment">// 哈希表大小，即table大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;<span class="comment">// 哈希表大小掩码，总等于size-1，用来计算索引值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;    <span class="comment">// 哈希表已有节点数量</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type; <span class="comment">// 类型特定函数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata; <span class="comment">// 私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];   <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">// rehash索引</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型特定函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);<span class="comment">// 计算哈希值</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);<span class="comment">// 复制键</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);<span class="comment">// 复制值</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);<span class="comment">// 比较键</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);<span class="comment">// 销毁键</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);<span class="comment">// 销毁值</span></span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><ul><li><img src="/redis_learn/3.png" alt=""></li><li>通过键值的void*类型，以及dictType的各种函数，字典实现了多态；</li><li>Redis的哈希表使用链地址法解决哈希冲突；</li><li>rehash相关的变量：<ul><li>通常只有ht[0]被使用，ht[1]只有在ht[0]进行rehash时才被使用；</li><li>rehashidx记录了rehash目前的进度，如果没有进行rehash则为-1；</li></ul></li><li>rehash全过程：<ol><li>为ht[1]分配空间。如果要扩展哈希表，ht[1]大小为第一个不小于(ht[0].used*2)的(2^n)值；如果要缩小哈希表，ht[1]大小为第一个不小于(ht[0].used)的(2^n)值；</li><li>将保存在ht[0]上的所有键值对rehash(重新计算哈希值、索引值)到ht[1]上；</li><li>当ht[0]的所有键值对都迁移到ht[1]上后，释放ht[0]，并将ht[0]设置为ht[1]，然后设置ht[1]为空，为下一次rehash做准备；</li></ol></li><li>是否rehash取决于服务器的状态和哈希表的负载因子；</li><li><strong>由于哈希表的大小可能很大，rehash可能无法一次性完成，因此需要分多次进行渐进式rehash：</strong><ol><li><strong>为ht[1]分配空间，方法和之前一样；</strong></li><li><strong>将索引计数器rehashidx设为0，表示rehash开始；</strong></li><li><strong>在rehash期间，每次对字典进行增删改查操作时，都会顺带将ht[0]在rehashidx索引上的所有键值对rehash到ht[1]中，并++rehashidx；</strong></li><li><strong>最终ht[0]中的所有键值对都会被rehash到ht[1]中，将rehashidx设为-1，释放ht[0]，ht[0]设置为ht[1]，ht[1]设为空，渐进式rehash完成；</strong></li><li><strong>渐进式rehash过程中，删改查会在ht[0]，ht[1]两个表上进行，增只会作用在ht[1]上，保证rehash一定能完成；</strong></li></ol></li></ul><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>Redis只有有序集合键和集群节点用到了跳表，跳表实现简单，效率与平衡树也差不多，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳跃表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span><span class="comment">// 前进指针</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;            <span class="comment">// 跨度</span></span><br><span class="line">    &#125; level[];                        <span class="comment">// 层数组</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span>   <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="keyword">double</span> score;                     <span class="comment">// 分值</span></span><br><span class="line">    robj   *obj;                      <span class="comment">// 成员对象</span></span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳跃表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span><span class="comment">// 表头表尾</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;              <span class="comment">// 表中节点数量</span></span><br><span class="line">    <span class="keyword">int</span>           level;               <span class="comment">// 表中节点最大层数</span></span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure><ul><li><img src="/redis_learn/4.png" alt=""></li><li>一个跳跃表节点可以在多层出现，level数组存放了所有层的节点；</li><li>span是一个节点的跨度，它是用来计算排位的（查找时累加跨度）；</li><li>backward用来反向遍历跳跃表；</li><li>每个跳跃表中，score可以相同，但obj必须唯一；</li><li>header、tail、length、level使得获取跳跃表的各种信息十分方便；</li></ul><h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>Redis使用整数集合作为集合键的实现之一，这样可以节省内存，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整数集合</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;  <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;    <span class="comment">// 集合元素数量，即content的长度</span></span><br><span class="line">    <span class="keyword">int8_t</span>   contents[];<span class="comment">// 元素数组</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><ul><li><img src="/redis_learn/5.png" alt=""></li><li>虽然contents声明为int8_t数组，但它的真正类型取决于encoding：<ul><li>if encoding == INTSET_ENC_INT16: contents is int16_t[]；</li><li>if encoding == INTSET_ENC_INT32: contents is int32_t[]；</li><li>if encoding == INTSET_ENC_INT64: contents is int64_t[]；</li></ul></li><li>contents中的元素总是有序的；</li><li>向整数集合中添加新元素时，如果现有类型无法容纳新元素，整数集合会<strong>升级：</strong><ol><li>根据新元素类型，扩展contents空间大小，重分配空间；</li><li>扩展集合中原来所有元素的类型，并将它们放到正确位置；</li><li>将新元素添加到contents中；</li></ol></li><li>升级带来的优点：<ol><li>提高灵活性：集合中可以同时容纳int16_t, int32_t, int64_t；</li><li>节省内存：升级使得集合在有需要的时候才会扩展空间；</li><li>升级使得整数集合既能保存三种类型的值，又在必要时候才升级；</li></ol></li><li><strong>不存在降级操作</strong>；</li></ul><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>Redis使用压缩列表作为列表键和散列键的实现之一，压缩列表是为了节省内存开发的。压缩列表没有具体的结构体，实际用一个指针表示，指针指向内存布局类似这样：</p><p><img src="/redis_learn/61.png" alt=""></p><ul><li>zlbytes: uint32_t，记录压缩列表的内存字节数；</li><li>zltail:  uint32_t，记录表尾节点距压缩列表起始地址的偏移量；</li><li>zllen:   uint16_t，记录压缩列表节点的数量；</li><li>entryX:  类型不定，是压缩列表节点；</li><li>zlend:   uint8_t，0xFF，标记压缩列表尾端；</li></ul><p>接下来讨论一下entryX的构成：</p><p><img src="/redis_learn/62.png" alt=""></p><ul><li>previous_entry_length: 记录前一个节点的长度，压缩列表利用它可以从表尾向表尾遍历；</li><li>encoding: 记录content保存数据的类型和长度，通过不同的特定编码来表示；</li><li>content: 节点的实际内容，由encoding决定其类型和长度；</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>Redis构建了一个对象系统，对象系统中有五种对象：字符串、列表、哈希、集合、有序集合，每种对象都有多种实现方式，每种实现方式都用到了上面介绍的数据结构。下面介绍这个对象系统：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis对象</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;<span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;<span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;<span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;<span class="comment">// 指向底层实现数据结构指针</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><ul><li>在Redis中创建一个键值对会创建两个对象，一个是键，一个是值；</li><li>type: 记录对象的类型，Redis根据这个字段判断一个给定的命令是否能应用到一个对象上，TYPE命令也依赖于这个字段：<ul><li>REDIS_STRING: 字符串</li><li>REDIS_LIST: 列表</li><li>REDIS_HASH: 哈希</li><li>REDIS_SET: 集合</li><li>RESID_ZSET: 有序集合</li></ul></li><li>encoding和ptr: 记录对象的底层实现数据结构，编码可以为：<ul><li>REDIS_ENCODING_INT: long类型的整数</li><li>REDIS_ENCODING_EMBSTR: embstr编码的简单动态字符串</li><li>REDIS_ENCODING_RAW: 简单动态字符串</li><li>REDIS_ENCODING_HT: 字典</li><li>REDIS_ENCODING_LINKEDLIST: 双端链表</li><li>REDIS_ENCODING_ZIPLIST: 压缩列表</li><li>REDIS_ENCODING_INTSET: 整数集合</li><li>REDIS_ENCODING_SKIPLIST: 跳跃表和字典</li></ul></li><li>每种对象都使用了多种编码，对应关系：</li></ul><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">编码</th><th style="text-align:left">对象</th></tr></thead><tbody><tr><td style="text-align:left">REDIS_STRING</td><td style="text-align:left">REDIS_ENCODING_INT</td><td style="text-align:left">使用整数值实现的字符串对象。</td></tr><tr><td style="text-align:left">REDIS_STRING</td><td style="text-align:left">REDIS_ENCODING_EMBSTR</td><td style="text-align:left">使用 embstr 编码的简单动态字符串实现的符串对象。</td></tr><tr><td style="text-align:left">REDIS_STRING</td><td style="text-align:left">REDIS_ENCODING_RAW</td><td style="text-align:left">使用简单动态字符串实现的字符串对象。</td></tr><tr><td style="text-align:left">REDIS_LIST</td><td style="text-align:left">REDIS_ENCODING_ZIPLIST</td><td style="text-align:left">使用压缩列表实现的列表对象。</td></tr><tr><td style="text-align:left">REDIS_LIST</td><td style="text-align:left">REDIS_ENCODING_LINKEDLIST</td><td style="text-align:left">使用双端链表实现的列表对象。</td></tr><tr><td style="text-align:left">REDIS_HASH</td><td style="text-align:left">REDIS_ENCODING_ZIPLIST</td><td style="text-align:left">使用压缩列表实现的哈希对象。</td></tr><tr><td style="text-align:left">REDIS_HASH</td><td style="text-align:left">REDIS_ENCODING_HT</td><td style="text-align:left">使用字典实现的哈希对象。</td></tr><tr><td style="text-align:left">REDIS_SET</td><td style="text-align:left">REDIS_ENCODING_INTSET</td><td style="text-align:left">使用整数集合实现的集合对象。</td></tr><tr><td style="text-align:left">REDIS_SET</td><td style="text-align:left">REDIS_ENCODING_HT</td><td style="text-align:left">使用字典实现的集合对象。</td></tr><tr><td style="text-align:left">REDIS_ZSET</td><td style="text-align:left">REDIS_ENCODING_ZIPLIST</td><td style="text-align:left">使用压缩列表实现的有序集合对象。</td></tr><tr><td style="text-align:left">REDIS_ZSET</td><td style="text-align:left">REDIS_ENCODING_SKIPLIST</td><td style="text-align:left">使用跳跃表和字典实现的有序集合对象</td></tr></tbody></table><ul><li>字符串对象:<br><img src="/redis_learn/71.png" alt=""><br><img src="/redis_learn/72.png" alt=""><br><img src="/redis_learn/73.png" alt="">  </li><li>列表对象：<br><img src="/redis_learn/74.png" alt=""><br><img src="/redis_learn/75.png" alt="">  </li><li>哈希对象：<br><img src="/redis_learn/76.png" alt=""><br><img src="/redis_learn/76_.png" alt=""><br><img src="/redis_learn/77.png" alt="">   </li><li>集合对象：<br><img src="/redis_learn/78.png" alt=""><br><img src="/redis_learn/79.png" alt="">  </li><li>有序集合对象：<br><img src="/redis_learn/710.png" alt=""><br><img src="/redis_learn/710_.png" alt=""><br><img src="/redis_learn/711.png" alt=""><br><img src="/redis_learn/711_.png" alt="">  </li><li>虽然Redis是C写的，但它的整个对象系统能根据type字段进行类型检查，根据type和encoding字段实现多态。</li><li>refcount：记录对象的引用计数，实现了对象之间的共享，节省内存，提高效率；</li><li>lru：记录对象的LRU时间或LFU数据；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>说说我对Haskell的执念</title>
      <link href="/haskell_obsession/"/>
      <url>/haskell_obsession/</url>
      
        <content type="html"><![CDATA[<p>先放上我个人认为很帅的图标：<br><img src="/haskell_obsession/haskell-logo.svg" alt="个人认为很帅气的图标"></p><p>谈到Haskell，当时我只是在网上偶然看到函数式编程，便起了兴趣，想去了解一下，毕竟大学时间比较多，多了解一些东西也是好的。经过知乎上一番搜索，最后是选择了Haskell来了解函数式语言，因为它比较<strong>纯</strong>（然而我现在也没接触过其他函数式语言，Lisp，Scala等，也不太懂到底怎么纯的……）。</p><p>既然想学，就要去搜一些Haskell的学习资料啦，现在让我来推荐的话，《Learn You a Haskell for Great Good!》、《Haskell WikiBook》、《Real World Haskell》大概是这三本，然后做做<a href="https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems" target="_blank" rel="noopener">H-99: Ninety-Nine Haskell Problems</a>就差不多入门了吧，然而我只看了第一本，初步领略了一下函数式编程的乐趣(?)就没再看了。</p><a id="more"></a><p><img src="/haskell_obsession/1.jpg" alt="我的入门书"></p><p>说说这本书，当时大概看了两个星期吧，前面还好，基本语法还是能明白的，到了后面就很迷糊了。没错，说的就是你，<strong>Monad</strong>。Monad专业劝退想学Haskell的人，我当时为了了解这东西，网上到处搜啊，知乎上看看，结果到现在记得最清楚的反而是那句让人哭笑不得的话：</p><p><strong>一个单子（Monad）说白了不过就是自函子范畴上的一个幺半群而已。</strong></p><p>自函子我能懂，幺半群我也知道，可这两个东西加起来又能干什么呢，这东西到底有什么实际含义呢，直到后来看了一个<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="noopener">图解Monad</a>才略微理解了一点，让我真正觉得恍然大悟的是《Haskell WikiBook》的<a href="https://en.wikibooks.org/wiki/Haskell/Category_theory" target="_blank" rel="noopener">Haskell/Category theory</a>，只有真正和范畴论结合在一起，才能深入理解Monad这东西。</p><p>那么我为什么又说我对Haskell有执念呢，因为今天我无意间看到了JS的回调地狱，忽然间就想到自己弃坑的Haskell，当时看到网上说，Monad这东西是可以优雅解决这个问题的，现在想想，Haskell通过高度抽象，把函数包了一层又一层，并有Functor、Applicative、Monad这些概念，就是为了<strong>纯</strong>，当然，也能优雅的解决一些过程式、面向对象语言的问题。于是自己仿佛又燃起了学习Haskell的热情，学习Haskell有一种学习数学的感觉，让我觉得还不错，但想了想马上就要实习生春招了，而自己意向方向的知识感觉还欠缺好多，便只好作罢。</p><p>从这件事反观一下，现在的时代节奏太快，人们未必能静下心来学一些东西，这几年算法大火，工资也高，学的人非常多，真正有技术的又有多少呢，当然更大了来说，整个IT都是这样，人们调侃说，嫌工资低，转行当程序员总没错，于是便进培训班培训培训，简历上吹吹牛，于是当个程序员，拿个还不错的工资。而我以后会不会也是如此，等到IT这行工资不行了，也转行去其它热门行业呢？</p><p>但愿自己以后不会盲目追逐，能静下心来学一些东西，深入学习技术，不只是Haskell，更是其它的无穷无尽的知识。也许我对Haskell的执念，不只是不愿做一个不懂Haskell的Haskell粉，更是对自己不要浮躁的警告吧，能够静下心来，不被名利所迷惑，有着追求，做自己真正想做的事。</p>]]></content>
      
      
      <categories>
          
          <category> 日常随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Haskell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>负载均衡是什么</title>
      <link href="/load_balance/"/>
      <url>/load_balance/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h2><p>我们都知道，当我们上网时，服务器无时无刻工作着，为我们提供服务。随着互联网的发展，业务流量越来越大且业务逻辑越来越复杂，单机服务器的性能已无法满足业务要求，为此，我们需要多台服务器进行性能的水平拓展，但如何平均地将流量分发到多台服务器上呢？这就是负载均衡。</p><h2 id="负载均衡的方法"><a href="#负载均衡的方法" class="headerlink" title="负载均衡的方法"></a>负载均衡的方法</h2><p>负载均衡整体上分为两大类：</p><ul><li>四层负载均衡：在OSI的前四层进行负载均衡，根据报文的目的地址和端口号，决定提供服务的服务器；</li><li>七层负载均衡：在OSI的整七层进行负载均衡，主要是在应用层，通过报文中的内容来决定提供服务的服务器；</li></ul><p><img src="/load_balance/0.png" alt=""></p><a id="more"></a><p>两者的区别：</p><ul><li>七层负载均衡因为要和客户建立连接，并分析报文内容，效率肯定低于仅起到一个转发作用的四层负载均衡；</li><li>七层负载均衡类似一个代理服务器，除了负载均衡之外，还可以起到缓存、保护的作用，使得应用系统更加灵活，而四层负载均衡只起到了类似路由转发的作用；</li></ul><h2 id="负载均衡的算法"><a href="#负载均衡的算法" class="headerlink" title="负载均衡的算法"></a>负载均衡的算法</h2><ol><li><p>随机算法</p><p> 随机分配，按照权重设置随机概率，调用量越大分布越均匀，按照概率设置权重后也比较均匀，且便于动态调整权重。</p></li><li><p>轮询和加权轮询</p><p> 若服务器处理能力相同，业务处理量差距不大，可轮询。</p><p> 如果服务器处理能力有差异，应根据相应的处理能力赋予服务器权重，让处理能力强的服务器处理更多的业务。</p></li><li><p>最少连接和加权最少连接</p><p> 最少连接：始终与处理连接数最少的服务器进行通信。</p><p> 加权最少连接：若服务器处理能力不同，为每台服务器赋予权重，根据权重分配连接。</p></li><li><p>哈希算法</p><p> 普通哈希或一致性哈希，一致性哈希更好，可防止某台服务器挂掉导致的波动。</p></li><li><p>IP地址散列</p><p> 管理发送方IP和目标方IP的散列，将来自同一发送方的分组转发到相同服务器。当客户端有一系列业务需要处理而必须和一个服务器反复通信时，该算法能够保证来自相同客户端的通信能够一直在同一服务器中进行处理。</p></li><li><p>URL散列</p><p>根据请求URL信息的散列，将发送到相同URL的请求转发到同一服务器。</p></li></ol><h2 id="负载均衡具体实现（DNS-gt-数据链路层-gt-IP-gt-HTTP）"><a href="#负载均衡具体实现（DNS-gt-数据链路层-gt-IP-gt-HTTP）" class="headerlink" title="负载均衡具体实现（DNS-&gt;数据链路层-&gt;IP-&gt;HTTP）"></a>负载均衡具体实现（DNS-&gt;数据链路层-&gt;IP-&gt;HTTP）</h2><ol><li>DNS域名解析负载均衡(延迟)</li></ol><p><img src="/load_balance/1.png" alt=""></p><p>通过在DNS服务器中配置多个A记录，每次域名解析都根据负载均衡算法返回一个不同的IP地址返回，使得A记录中所有的服务器构成一个集群，实现负载均衡。</p><p>优点是将负载均衡的工作交给了DNS，免去了网络管理，但由于DNS有缓存，当服务器集群发生变化时，网站可能暂时无法访问，且网站本身无法控制这种现象。</p><ol><li>数据链路层负载均衡(LVS)</li></ol><p><img src="/load_balance/2.png" alt=""></p><p>通过在数据链路层修改mac地址进行负载均衡。这种方式并不修改IP地址，只修改mac地址，又称直接路由方式。</p><p>从图中可以看出，请求到达负载均衡服务器后，负载均衡服务器将目的mac地址更改为真正的服务器地址，服务器处理完数据可直接将相应数据发送给用户，这种数据传输方式称作三角传输模式。</p><ol><li>IP负载均衡(SNAT)</li></ol><p><img src="/load_balance/3.png" alt=""></p><p>通过在网络层修改目的地址进行负载均衡。当请求到达负载均衡服务器后，负载均衡服务器根据负载均衡算法修改IP地址，传送给真实服务器。</p><p>这种方法的关键是真实服务器如何将响应数据返回给用户，一种方式是负载均衡服务器在修改目的IP地址时同时修改源IP地址，另一种方式是将负载均衡服务器作为真实服务器的网关服务器。</p><p>优点是IP负载均衡在内核完成数据分发，性能较好，但由于所有的数据包都要经过负载均衡服务器，负载均衡服务器的性能将成为瓶颈。</p><p>4、HTTP重定向负载均衡(少见)</p><p><img src="/load_balance/4.png" alt=""></p><p>利用HTTP的302重定向响应让用户再次访问真正服务器。优点是简单，缺点是用户需要请求两次，效率太低，且HTTP重定向服务器处理能力可能成为瓶颈。</p><p>5、反向代理负载均衡(nginx)</p><p><img src="/load_balance/5.png" alt=""></p><p>也称应用层负载均衡。所有的请求都必须经过反向代理服务器，然后由反向代理服务器转发给真实服务器处理，反向服务器不仅可以进行负载均衡，还可以起到缓存加速的作用。优点是部署简单，缺点是反向代理服务器能力可能成为瓶颈。</p><p><strong>参考</strong></p><ul><li><a href="https://segmentfault.com/a/1190000004492447" target="_blank" rel="noopener">负载均衡算法及手段</a></li><li><a href="https://www.cnblogs.com/danbing/p/7459224.html" target="_blank" rel="noopener">负载均衡基础知识</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈Google C++代码风格</title>
      <link href="/google_code_style/"/>
      <url>/google_code_style/</url>
      
        <content type="html"><![CDATA[<p>C++作为一门极其复杂的语言，使用好它是十分困难的，C++的灵活语法和复杂特性使得C++变得无比强大，但这也导致它变得十分复杂，曾经我觉得使用越多高级特性的代码就越厉害，而现在我无法赞同，绝大多数情况下，代码的可读性和可维护性是第一位的，而C++正是因此而变成了“最难”的语言，不同人、团队的C++代码风格相差甚远，各种技巧用得飞起，在这种情况下，如果能有一个规范，使得代码尽量统一，就能在一定程度上解决C++代码难以维护的问题。</p><p>尽管Google C++代码风格是针对Google自身情况制定的，限制和禁止了很多特性(由于历史原因等)，但对于我这种新手，仍十分有帮助。</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><ul><li>一个头文件要自给自足，使用者没有义务知道头文件是否依赖其他的头文件并自行包含。</li><li>根据#include头文件的原理，头文件的确是可以用来插入文本的，学习一下。</li><li>防止多次包含是常识。</li><li>超过10行、递归、含有循环和switch的函数不应内联。<a id="more"></a></li><li><p>头文件的包含顺序应该是：</p><ol><li>与本文件最相关的头文件</li><li>C系统文件</li><li>C++系统文件</li><li>其他库的文件</li><li><p>本项目的文件</p><p>这样可以避免隐藏的依赖，并且保证内部错误及时被发现。</p></li></ol></li><li>在#include中插入空行分割各类头文件能增加可读性</li><li>头文件以绝对路径包含也能增加可读性。</li><li>用到的所有头文件都应包含，就算你知道a.h已经被b.h包含了，后来维护的人可不一定知道啊。</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li>内联命名空间一般只用于跨版本库的兼容性。</li><li>命名空间的最后注释出命名空间的名字。</li><li>只是为了封装静态成员函数而不共享静态数据创建的类，可用命名空间替代。</li><li>尽可能的降低代码耦合性。</li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li>避免隐式类型转换，记得加explicit。</li><li>分清拷贝和移动，如果你不知道类是否需要拷贝，就不要让类可以拷贝。</li><li>继承分清”has-a”和”is-a”，组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承，多重继承几乎用不到。</li><li>避免重载运算符。</li><li>声明次序: public -&gt; protected -&gt; private；</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li>函数尽量短小。</li><li>重载函数请保证用户能分清到底调用的是哪个函数，实在不行在函数名里加上参数信息。</li><li>避免使用默认参数，默认参数在虚函数中无法正常工作，且会干扰函数指针。</li></ul><h3 id="其他C-特性"><a href="#其他C-特性" class="headerlink" title="其他C++特性"></a>其他C++特性</h3><ul><li>不用异常，但我认为这只是Google的历史问题，如果是新项目，还是可以用的。</li><li>请用断言来保证变量非负，使用无符号型会有bug。</li><li>size(void *) != sizeof(int)，intptr_t才表示一个指针大小的整数。</li><li>少用宏，毕竟C++里有内联函数和const变量。</li><li>sizeof时想清楚想要的是变量的大小还是类型的大小。</li></ul><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul><li>命名要有描述性。</li><li>文件名全小写，用 _ 或 - 分割单词。</li><li>类型名每个单词首字母均大写；</li><li>普通变量和结构体变量全小写，单词用 _ 分割。</li><li>类数据成员在最后接下划线，这一点我认为很好用。</li><li>常量开头加k然后每个单词首字母都大写。</li><li>函数名也是每个单词首字母都大写。</li><li>枚举名要么和常量一样，要么和宏一样(全大写)。</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li>注释要在合适的地方。</li><li>TODO是个好习惯。</li></ul><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul><li>最后有一张图，一看便知。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Google C++代码风格除了命名和格式，别的建议更像是Effective C++系列，有很多坑都在这本书上提过（这可是学C++不可不读的一本特别好的书）。</p><p>关于代码风格，最重要的一点就是：</p><p><strong>保持一致</strong></p><p>代码是给人看的，只要别人看得懂，就是ok的，代码规范也只是一个建议。</p><p>最后放一张从网上找来的图，简洁明了地总结了大部分上述知识。</p><p><img src="/google_code_style/1.jpg" alt="Google C++代码风格"></p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>APUE-IPC部分</title>
      <link href="/apue_ipc/"/>
      <url>/apue_ipc/</url>
      
        <content type="html"><![CDATA[<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><ul><li>管道是半双工的，且只能在有公共祖先的两个进程之间使用；</li><li>fd[0]可读，fd[1]可写；</li><li><p>通常用法是先pipe，然后fork，这样父子进程就可以通信：</p><p>  <img src="/apue_ipc/151.png" alt="fork后的管道"></p></li><li><p>读一个写端已关闭的管道，在所有数据都读取后，read返回0，表示文件结束；</p></li><li>写一个读端已关闭的管道，会产生SIGPIPE，write返回-1，errno设置为EPIPE；</li><li>若多个进程同时写管道，且写字节数超过PIPE_BUF，则数据可能相互交叉；</li></ul><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>这是标准IO库提供的函数；</li><li><p>popen先创建管道，然后fork，根据type决定对管道的处理，然后exec command，最后返回一个FILE指针：</p><p>  <img src="/apue_ipc/152.png" alt=""></p><p>  <img src="/apue_ipc/153.png" alt=""></p></li><li><p>pclose关闭标准IO流，返回command终止状态；</p></li></ul><h4 id="协同进程"><a href="#协同进程" class="headerlink" title="协同进程"></a>协同进程</h4><p>当进程A既读取进程B的输出，同时也产生进程B的输入时，就称进程A是进程B的协同进程，因为进程A的输入和输出都是在为进程B服务。</p><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>也被称为命名管道，可以在不相关的两个进程间使用，半双工；</li><li>FIFO是一种文件类型，创建类似创建文件；</li><li>mkfifo类似open，mkfifoat类似openat；</li><li>使用open来打开一个FIFO：<ul><li>阻塞打开(不指定O_NONBLOCK)时，只读open阻塞至其他进程写open为止，反之亦然；</li><li>非阻塞打开(指定O_NONBLOCK)时，只读open立刻返回，而只写open时若没有其他进程读open，则出错返回-1，并设置errno为ENXIO；</li><li>类似管道，写一个无进程读的FIFO会产生SIGPIPE，当FIFO最后一个写进程关闭FIFO时，为FIFO读进程产生一个EOF；</li></ul></li><li>FIFO可以被多个进程写，如果不希望写数据交叉，应根据PIPE_BUF大小考虑原子写最大数据量；</li><li><p>FIFO的用途：</p><ul><li><p>shell命令将数据从一条管道传到另一条，且无需创建中间临时文件:</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfifo fifo1</span><br><span class="line">prog3 &lt; fifo1 &amp;</span><br><span class="line">prog &lt; infile | tee fifo1 | prog2</span><br></pre></td></tr></table></figure><p>  <img src="/apue_ipc/154.png" alt="将一个输入流发送给两个不同进程"></p></li><li><p>C-S应用程序中，FIFO用作汇聚点在C和S两者之间传递数据：</p><p>  <img src="/apue_ipc/155.png" alt="使用FIFO进行C-S通信"></p></li></ul></li></ul><h3 id="XSI-IPC"><a href="#XSI-IPC" class="headerlink" title="XSI IPC"></a>XSI IPC</h3><p>消息队列，信号量，共享存储，这三种IPC都在内核中被一个非负整数标识符引用，而由于这个标识符是IPC对象的内部命名，需要提供一个外部命名供进程引用，因此每个IPC对象都与一个键关联，键是IPC对象的外部名。</p><p>如何让多个进程在同一IPC结构上汇聚？</p><ol><li>可以指定IPC_PRIVATE创建一个新IPC结构，然后保存标识符供进程使用；</li><li>在公共文件中定义一个公认键，但要处理键已经关联的情况；</li><li><p>使用ftok产生一个键值，然后用这个值创建IPC结构：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">key_t</span> ftok(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id);</span><br></pre></td></tr></table></figure></li></ol><p>msgget, semget, shmget都有类似的参数: key和flag：</p><ul><li>如果要创建一个IPC结构，则key应该是IPC_PRIVATE或者与当前IPC结构无关且指定IPC_CREAT标志位；</li><li>如果要引用一个现有IPC结构，key必须等于创建时的key值，且不能指定IPC_CREAT；</li><li>IPC_PRIVATE总是用来创建新IPC结构的，为了引用用IPC_PRIVATE创建的IPC结构，必须知道其相关的标识符，然后在其他IPC调用中跳过get函数，使用此标识符；</li></ul><p>每个IPC结构都关联了一个ipc_perm结构，其中包含了IPC结构的各种权限设置。</p><p>XSI IPC的优缺点：</p><ul><li>IPC结构是在系统范围内作用的，没有引用计数，即使没有进程使用它，只要不显式读取或删除，它就会一直留在系统里；</li><li>这些IPC结构在文件系统里没有名字，操作不便，也无法对其进行IO复用(select和poll)；</li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg_first</span>;</span><span class="comment">/* first message on queue,unused  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg_last</span>;</span><span class="comment">/* last message in queue,unused */</span></span><br><span class="line"><span class="keyword">__kernel_time_t</span> msg_stime;<span class="comment">/* last msgsnd time */</span></span><br><span class="line"><span class="keyword">__kernel_time_t</span> msg_rtime;<span class="comment">/* last msgrcv time */</span></span><br><span class="line"><span class="keyword">__kernel_time_t</span> msg_ctime;<span class="comment">/* last change time */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>  msg_lcbytes;<span class="comment">/* Reuse junk fields for 32 bit */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>  msg_lqbytes;<span class="comment">/* ditto */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> msg_cbytes;<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> msg_qnum;<span class="comment">/* number of messages in queue */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> msg_qbytes;<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line"><span class="keyword">__kernel_ipc_pid_t</span> msg_lspid;<span class="comment">/* pid of last msgsnd */</span></span><br><span class="line"><span class="keyword">__kernel_ipc_pid_t</span> msg_lrpid;<span class="comment">/* last receive pid */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> msgrcv(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;       <span class="comment">/* message type, must be &gt; 0 */</span></span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1</span>];    <span class="comment">/* message data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>消息队列是消息的链表，存储在内核中，由队列ID标识；</li><li>每个队列都和一个msqid_ds结构关联，此结构描述了队列的当前状态；</li><li>msgget创建或引用一个队列，返回队列ID；</li><li>msgctl对队列执行各种操作：<ul><li>IPC_STAT：获取队列的msqid_ds结构并存放在buf中；</li><li>IPC_SET：将buf中的msg_perm.uid, msg_perm.gid, msg_perm.mode, msg_qbytes赋予队列相关结构中；</li><li>IPC_RMID：删除消息队列和消息队列中的所有数据，删除立刻生效，之后对此队列进行操作将得到EIDRM错误；</li></ul></li><li>msgsnd将数据放到消息队列中：<ul><li>msgp指向一个msgbuf结构，mtext的长度为msgsz；</li><li>msgflg可以是IPC_NOWAIT，即非阻塞；</li><li>msgsnd返回成功时会更新相关的msqid_ds结构；</li></ul></li><li>msgrcv从消息队列中获取数据：<ul><li>msgp指向一个msgbuf结构，mtext指向缓冲区，大小为msgsz；</li><li>msgtyp指定想取的消息：<ul><li>==0：返回队列第一个消息；</li><li>>0：返回队列中mtype为msgtyp的消息；</li><li>\&lt;0：返回队列中mtype \&lt;= msgtyp绝对值的消息，先取最小的；</li></ul></li><li>msgflg可以为IPC_NOWAIT，即非阻塞；</li><li>msgrcv返回成功时会更新相关的msqid_ds结构；</li></ul></li></ul><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span><span class="title">sem_perm</span>;</span><span class="comment">/* permissions .. see ipc.h */</span></span><br><span class="line"><span class="keyword">__kernel_time_t</span>sem_otime;<span class="comment">/* last semop time */</span></span><br><span class="line"><span class="keyword">__kernel_time_t</span>sem_ctime;<span class="comment">/* last change time */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span>*<span class="title">sem_base</span>;</span><span class="comment">/* ptr to first semaphore in array */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">sem_pending</span>;</span><span class="comment">/* pending operations to be processed */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> **<span class="title">sem_pending_last</span>;</span><span class="comment">/* last pending operation */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span>*<span class="title">undo</span>;</span><span class="comment">/* undo requests on this array */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>sem_nsems;<span class="comment">/* no. of semaphores in array */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">size_t</span> nsops)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>  sem_num;<span class="comment">/* semaphore index in array */</span></span><br><span class="line"><span class="keyword">short</span>sem_op;<span class="comment">/* semaphore operation */</span></span><br><span class="line"><span class="keyword">short</span>sem_flg;<span class="comment">/* operation flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>信号量是一个计数器，用于控制多个进程对共享数据对象的访问；</li><li>XSI信号量有3种特性：<ul><li>信号量必须是一个或多个信号量的集合，创建时要指定数量；</li><li>信号量的创建和初始化是独立的，这意味着无法原子性的创建并初始化信号量集；</li><li>即使没有进程使用信号量，信号量依然存在，undo可以解决这个问题；</li></ul></li><li>每个信号量都和一个semid_ds结构关联，此结构描述了信号量的当前状态；</li><li>semget创建或引用一个信号量，返回信号量ID，nsems是集合中的信号量数，引用信号量则应设置为0；</li><li>semctl对队列进行各种操作，类似msgctl，不过选项更多；</li><li>semop对信号量进行操作，操作取决于sembuf数组：<ul><li>sem_num指定对哪个信号量操作；</li><li>sem_op为正意味着释放资源，为负意味着获取资源，为0意味着调用进程希望等待到该信号量变为0；</li><li>sem_flg可以为IPC_NOWAIT，意味着非阻塞；</li><li>sem_flg可以指定SEM_UNDO标志，之后分配资源时内核会记住信号量调整量，这样当进程终止时，如果进程没有对信号量进行调整，内核会对相应信号量进行调整；</li></ul></li><li>semop是个原子操作，操作数组要么全执行，要么都不执行；</li></ul><h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span><span class="title">shm_perm</span>;</span><span class="comment">/* operation perms */</span></span><br><span class="line"><span class="keyword">int</span>shm_segsz;<span class="comment">/* size of segment (bytes) */</span></span><br><span class="line"><span class="keyword">__kernel_time_t</span>shm_atime;<span class="comment">/* last attach time */</span></span><br><span class="line"><span class="keyword">__kernel_time_t</span>shm_dtime;<span class="comment">/* last detach time */</span></span><br><span class="line"><span class="keyword">__kernel_time_t</span>shm_ctime;<span class="comment">/* last change time */</span></span><br><span class="line"><span class="keyword">__kernel_ipc_pid_t</span>shm_cpid;<span class="comment">/* pid of creator */</span></span><br><span class="line"><span class="keyword">__kernel_ipc_pid_t</span>shm_lpid;<span class="comment">/* pid of last operator */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>shm_nattch;<span class="comment">/* no. of current attaches */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> shm_unused;<span class="comment">/* compatibility */</span></span><br><span class="line"><span class="keyword">void</span> *shm_unused2;<span class="comment">/* ditto - used by DIPC */</span></span><br><span class="line"><span class="keyword">void</span>*shm_unused3;<span class="comment">/* unused */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>共享存储允许多个进程共享一个给定的存储区，这是最快的一种IPC，因为不需要在各个进程之间进行拷贝，但是需要同步；</li><li>mmap就是共享存储的一种形式，只不过mmap映射的文件真实存在，XSI共享存储是内存的匿名段；</li><li>每个共享存储段都和一个shmid_ds结构关联，此结构描述了共享存储段的当前状态；</li><li>shmget创建或引用一个共享存储段，size为共享存储段的大小，引用时应指定为0；</li><li>shmctl对共享存储段进行各种操作，类似msgctl；</li><li>shmat将获取的共享存储段连接到进程的地址空间中，如果shmaddr为0，则由内核选择连接地址，非0则连接到指定地址；shmat返回实际连接的地址；</li><li>shmat中，如果shmflg为SHM_RDONLY，则以只读方式连接，否则以读写方式连接；</li><li>shmdt将共享存储段与进程分离，但并不删除共享存储段，应以IPC_RMID调用shmctl才能删除；</li></ul><h4 id="dev-zero的存储映射"><a href="#dev-zero的存储映射" class="headerlink" title="/dev/zero的存储映射"></a>/dev/zero的存储映射</h4><p>对/dev/zero的存储映射将创建一个未命名的存储区，长度为mmap的第二个参数并向上取整为系统页长，存储区初始化为0，可以用来在有共同祖先的进程间充当共享存储区。</p><p>也可以在mmap中指定MAP_ANON标志并将fd指定为-1来进行匿名存储映射。</p><h3 id="POSIX信号量"><a href="#POSIX信号量" class="headerlink" title="POSIX信号量"></a>POSIX信号量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> *sem_open(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag,... <span class="comment">/*mode_t mode, unsigned int value*/</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_close</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">const</span> struct timespec *abs_timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> *sval)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sem_open创建或引用一个现有的命名信号量，创建时要指定O_CREAT标志并提供mode权限参数和value信号量初始值，引用只需name并指定oflag为0，sem_open返回指向信号量的指针；</li><li>sem_close释放信号量相关的资源，但并不影响信号量状态；</li><li>sem_unlink销毁一个命名信号量；</li><li>sem_*wait对信号量进行减一操作；</li><li>sem_post对信号量进行增一操作；</li><li>如果想要使用未命名信号量，声明一个sem_t变量并用sem_init初始化，用sem_destroy销毁；</li><li>sem_getvalue获取信号量的值，注意，返回的值不一定是信号量的当前值，因为获取值后信号量的值可能已经变了；</li></ul><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>套接字是一种网络IPC，当然本地也可以用，但效率不如其他专用于本地的IPC高，详情见UNP笔记。</p><h3 id="UNIX域套接字"><a href="#UNIX域套接字" class="headerlink" title="UNIX域套接字"></a>UNIX域套接字</h3><p>UNIX域套接字的关键在于可以传递文件描述符，它类似网络套接字，不过只用于本地。</p><h4 id="匿名UNIX域套接字"><a href="#匿名UNIX域套接字" class="headerlink" title="匿名UNIX域套接字"></a>匿名UNIX域套接字</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sv[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>创建一对匿名相互连接的UNIX域套接字，类似全双工管道：</p><p>  <img src="/apue_ipc/171.png" alt="套接字对"></p></li></ul><h4 id="命名UNIX域套接字"><a href="#命名UNIX域套接字" class="headerlink" title="命名UNIX域套接字"></a>命名UNIX域套接字</h4><p>类似绑定因特网域套接字，只不过地址应该是一个文件系统的路径名，且此文件不应该存在。</p><h4 id="传递文件描述符"><a href="#传递文件描述符" class="headerlink" title="传递文件描述符"></a>传递文件描述符</h4><p>传递文件描述符不是简单地传递一个数值，在传递过程中，文件描述符会被复制，文件的引用计数也会加一，而描述符编号也通常是不同的，类似于dup：</p><p><img src="/apue_ipc/172.png" alt="传递文件描述符后"></p><p>为了使用UNIX域套接字传递文件描述符，要调用sendmsg和recvmsg函数，指定msghdr结构中的msg_control和msg_controllen参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>         *msg_name;       <span class="comment">/* optional address */</span></span><br><span class="line">    <span class="keyword">socklen_t</span>     msg_namelen;    <span class="comment">/* size of address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>        <span class="comment">/* scatter/gather array */</span></span><br><span class="line">    <span class="keyword">size_t</span>        msg_iovlen;     <span class="comment">/* # elements in msg_iov */</span></span><br><span class="line">    <span class="keyword">void</span>         *msg_control;    <span class="comment">/* ancillary data, see bel*/</span></span><br><span class="line">    <span class="keyword">size_t</span>        msg_controllen; <span class="comment">/* ancillary data buffer l*/</span></span><br><span class="line">    <span class="keyword">int</span>           msg_flags;      <span class="comment">/* flags (unused) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">socklen_t</span>     cmsg_len;       <span class="comment">/* data byte count, including header */</span></span><br><span class="line">    <span class="keyword">int</span>           cmsg_level;     <span class="comment">/* originating protocol */</span></span><br><span class="line">    <span class="keyword">int</span>           cmsg_type;      <span class="comment">/* protocol-specific type */</span></span><br><span class="line">    <span class="comment">/* followed by the actual control message data */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*cmsg_len=CMSG_LEN(nbytes);</span></span><br><span class="line"><span class="comment">  cmsg_level=SOL_SOCKET;</span></span><br><span class="line"><span class="comment">  cmsg_type=SCM_RIGHTS; */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> APUE总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UNIX </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> IPC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>APUE-高级I/O部分</title>
      <link href="/apue_advio/"/>
      <url>/apue_advio/</url>
      
        <content type="html"><![CDATA[<h2 id="高级IO"><a href="#高级IO" class="headerlink" title="高级IO"></a>高级IO</h2><h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p>对于可能使进程永远阻塞的系统调用，如果不想进程一直阻塞，可以将系统调用设为非阻塞：</p><ul><li>open时指定O_NONBLOCK标志；</li><li>fcntl对一个打开的描述符设置O_NONBLOCK标志；</li></ul><p>这样，如果系统调用无法满足要求，会立刻返回并设定相应错误标志。</p><h3 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h3><p>记录锁保证不会有多个进程同时修改一个文件的<strong>同一区域</strong>，设置记录锁的POSIX方法是通过fcntl：</p><ul><li>cmd为F_GETLK, F_SETLK, F_SETLKW, arg是指向flock结构的指针；</li></ul><a id="more"></a><ul><li><p>flock结构如下：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> l_type;   <span class="comment">// F_RDLCK, F_WRLCK, F_UNLCK</span></span><br><span class="line">    <span class="keyword">short</span> l_whence; <span class="comment">// SEEK_SET, SEEK_CUR, SEEK_END</span></span><br><span class="line">    <span class="keyword">off_t</span> l_start;  <span class="comment">// 偏移量</span></span><br><span class="line">    <span class="keyword">off_t</span> l_len;    <span class="comment">// 区域长度，0表示锁到EOF</span></span><br><span class="line">    <span class="keyword">pid_t</span> l_pid;    <span class="comment">// 锁的持有者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同一进程重复加锁会替换之前的锁；</p></li><li>锁与进程和文件都关联，进程终止锁全部释放，<strong>而即使描述符引用计数大于1，只要任何一个描述符关闭，描述符引用文件的锁全部释放</strong>，这是因为锁信息存放在v节点中，而锁信息并没有记录究竟是谁加的锁；</li><li>fork不会继承锁，exec取决是否设置exec关闭标志；</li><li>在文件尾端加锁要注意；</li></ul><h3 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">nt <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">            fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">            fd_set *exceptfds, <span class="keyword">const</span> struct timespec *timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>nfds是最大fd加1；</li><li>每次调用要重新设置关心的描述符集；</li><li>描述符是否阻塞不影响select；</li><li>timeout为NULL无限等待，等于0非阻塞；</li><li>pselect时间更精确，可原子安装信号屏蔽字；</li><li>select监听的描述符上限取决于fd_set类型的大小；</li></ul><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ppoll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct timespec *tmo_p, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>和select本质一样，都是轮询，只是接口不同，基本没有上限；</li></ul><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>和同步IO相比，异步IO会替永远替进程完成所有的IO操作，然后才通知进程，而无论是阻塞IO、非阻塞IO、IO复用、信号驱动IO，都只是通知可以进行IO操作的方式不同，进程还是要自己把数据取出或写入。</p><h3 id="readv和writev"><a href="#readv和writev" class="headerlink" title="readv和writev"></a>readv和writev</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</span><br><span class="line"><span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</span><br><span class="line"><span class="keyword">ssize_t</span> preadv(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt, <span class="keyword">off_t</span> offset);</span><br><span class="line"><span class="keyword">ssize_t</span> pwritev(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt, <span class="keyword">off_t</span> offset);</span><br></pre></td></tr></table></figure><ul><li>分散读、集中写。</li></ul><h3 id="存储映射IO"><a href="#存储映射IO" class="headerlink" title="存储映射IO"></a>存储映射IO</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>mmap将一个磁盘文件映射到进程内存中；</li><li>addr为映射起始地址，通常为0，代表由系统选择地址；</li><li>fd是被映射的文件描述符，offset是偏移量，length是映射长度；</li><li>prot是对映射区的保护要求，不能和fd打开模式冲突：<ul><li>PROT_READ：可读；</li><li>PROT_WRITE：可写；</li><li>PROT_EXEC：可执行；</li><li>PROT_NONE：不可访问；</li></ul></li><li>flags是属性：<ul><li>MAP_FIXED：映射地址必须是addr；</li><li>MAP_SHARED：允许进程修改映射区；</li><li>MAP_PRIVATE：对映射区的写操作会创建一个进程的副本；</li></ul></li><li><p>映射区域如下：</p><p>  <img src="/apue_advio/141.png" alt="映射区域"></p></li><li>mprotect可以更改映射区权限；</li><li>msync类似fsync；</li><li>munmap解除映射；</li></ul>]]></content>
      
      
      <categories>
          
          <category> APUE总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UNIX </tag>
            
            <tag> I/O </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>APUE-线程部分</title>
      <link href="/apue_thread/"/>
      <url>/apue_thread/</url>
      
        <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程特点"><a href="#线程特点" class="headerlink" title="线程特点"></a>线程特点</h3><ul><li>可以简化异步代码；</li><li>共享进程资源；</li><li>自身仍有线程ID，寄存器，栈，调度信息，信号屏蔽字，errno，线程私有数据；</li><li>需要同步，一个线程异常会导致整个进程异常；</li></ul><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tid1, <span class="keyword">pthread_t</span> tid2)</span></span>;</span><br><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line">                void *(*start_routine) (void *), void *arg);</span><br></pre></td></tr></table></figure><ul><li>tid存入thread指向空间；</li><li>attr定义线程属性：<ul><li>初始化一个属性对象传入；</li><li>通过pthread_attr_setdetachstate()设置detachstate属性可使线程创建时就是detach态；</li></ul></li><li>线程从start_routine地址开始运行，参数为arg。</li></ul><a id="more"></a><h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><p>线程终止方式：</p><ul><li>简单return；</li><li>被其他线程pthread_cancel；</li><li>自身pthread_exit。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *rval_ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **rval_ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br><span class="line">void pthread_cleanup_push(void (*routine)(void *), void *arg);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>pthread_cancel仅提出请求；</li><li>detach态的线程终止后资源立刻被回收；</li><li><p>和进程的对比：</p><p>  <img src="/apue_thread/111.png" alt="进程线程函数对比"></p></li></ul><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a><strong>线程同步</strong></h3><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>互斥：一个资源只能给一个进程使用；</li><li>不可剥夺：进程获得的资源在使用完毕前不可被其它进程剥夺；</li><li>请求和保持：进程占用已获得的资源，并且同时申请新的资源；</li><li>循环等待：存在一个资源等待循环，使得每个进程都无法满足条件；</li></ul><h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> pthread_mutex_unlock(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> *<span class="title">restrict</span> <span class="title">tsptr</span>);</span></span><br></pre></td></tr></table></figure><ul><li>互斥量就是一把锁，使用前加锁，使用后解锁，一把锁只能被一个线程拥有，其它想要加锁的线程只能等待；</li><li>静态分配互斥量可用PTHREAD_MUTEX_INITIALIZER初始化；</li><li><p>属性：</p><ul><li>进程共享属性：允许多个进程利用互斥量同步；</li><li>健壮属性：与多个进程使用互斥量有关；</li><li><p>类型属性：</p><p>  <img src="/apue_thread/121.png" alt="互斥量类型行为"></p></li></ul></li></ul><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedwrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>类似互斥量，但是读写锁允许多个读者，只允许一个写者；</li><li>适合读频率大于写频率的数据；</li><li>为了避免写者饥饿，在写锁阻塞后，后来的读锁可能会阻塞；</li><li>属性：<ul><li>进程共享属性；</li></ul></li></ul><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>条件变量允许线程以无竞争的方式等待特定的条件发生；</li><li>条件变量和互斥量一起使用，条件由互斥量保护；</li><li>pthread_cond_wait调用时进行条件检查和解锁互斥量，返回时再次锁住互斥量；</li><li>由于条件改变后到等待线程锁住互斥量之间条件可能改变，应在pthread_cond_wait返回后再次检查条件；</li><li>属性：<ul><li>进程共享属性；</li><li>时钟属性：控制超时参数使用哪个时钟；</li></ul></li></ul><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_init</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock, <span class="keyword">int</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_destroy</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_lock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_trylock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_unlock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>自旋锁类似互斥量，但它不阻塞线程，而是在获得锁之前一直忙等；</li><li>如果持锁时间短，且不希望线程在重新调度上花太多时间，可以用自旋锁；</li><li>自旋锁通常用于底层，内核中自旋锁可以阻塞中断，防止死锁；</li></ul><h4 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_init</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *<span class="keyword">restrict</span> barrier,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span> *<span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_destroy</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_wait</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>屏障可以协调多个线程并行工作，允许合作线程共同到达某一点后再继续向后工作；</li><li>屏障可以重用，但计数一旦初始化，就无法改变；</li><li>属性：<ul><li>进程共享属性；</li></ul></li></ul><h3 id="线程取消选项"><a href="#线程取消选项" class="headerlink" title="线程取消选项"></a>线程取消选项</h3><p>影响线程响应pthread_cancel的行为。</p><h3 id="线程与信号"><a href="#线程与信号" class="headerlink" title="线程与信号"></a>线程与信号</h3><p>虽然每个线程有各自的信号屏蔽字，但它们共享信号处理函数，并且在线程中与信号有关的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_sigmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigwait</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">int</span> *<span class="keyword">restrict</span> signop)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_kill</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">int</span> signo)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sigwait阻塞进程，等待set中的信号到来，然后将信号从等待队列中移除；</li><li>在sigwait之前，应将set中的所有信号阻塞；</li><li>利用sigwait，可以将想阻塞的信号加到每个线程中，然后创建一个专门的线程处理信号，从而简化代码中的信号处理；</li><li>alarm定时器是进程资源，所有线程共享；</li></ul><h3 id="线程与fork"><a href="#线程与fork" class="headerlink" title="线程与fork"></a>线程与fork</h3><p>多线程进程fork的主要问题在于，子进程内部只存在一个线程，这个线程是父进程中调用fork的线程，同时子进程会继承父进程所有的锁，但子进程中并没有占用锁的线程，如何清理锁是个问题：</p><ul><li>如果立刻exec则无需考虑这个问题，exec后旧的空间被丢弃，锁状态无所谓，但在exec前只能调用异步信号安全的函数；</li><li>如果不exec，可以通过pthread_atfork()清楚锁状态；</li></ul><h3 id="线程与IO"><a href="#线程与IO" class="headerlink" title="线程与IO"></a>线程与IO</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset);</span><br><span class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset);</span><br></pre></td></tr></table></figure><ul><li>由于线程共享文件描述符，pread和pwrite提供的原子(lseek+read/write)操作是很有用的；</li></ul>]]></content>
      
      
      <categories>
          
          <category> APUE总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UNIX </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>APUE-信号部分</title>
      <link href="/apue_signal/"/>
      <url>/apue_signal/</url>
      
        <content type="html"><![CDATA[<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h3 id="什么是信号"><a href="#什么是信号" class="headerlink" title="什么是信号"></a>什么是信号</h3><p>信号提供的是一种处理异步事件的方法，有很多种信号，很多条件可以产生信号，对于进程来说，信号何时发生是无法预测的，进程只能保证当信号发生时做什么，有下面三种做法：</p><ol><li>忽略信号：SIGKILL和SIGSTOP无法忽略；</li><li>捕捉信号：捕捉信号并调用指定函数，SIGKILL和SIGSTOP无法捕捉；</li><li>执行系统默认动作；</li></ol><h3 id="中断的系统调用"><a href="#中断的系统调用" class="headerlink" title="中断的系统调用"></a>中断的系统调用</h3><p>当执行一个慢速系统调用——可能使进程永远阻塞的系统调用——阻塞时，若捕捉到信号，则此系统调用被中断，出错返回并设置EINTR，<strong>有的系统调用会自动重启，有的不会</strong>，请注意。</p><a id="more"></a><h3 id="信号的产生和递交"><a href="#信号的产生和递交" class="headerlink" title="信号的产生和递交"></a>信号的产生和递交</h3><p>产生信号和递交信号之间，信号是未决的，递交信号时，若进程阻塞信号递交，则信号保持未决态，直到进程解除阻塞或直接忽略信号，在信号处于未决态时，若同一信号发生多次，信号可能排队，也可能只递交一次，同时多个信号的递交顺序也是不确定的。</p><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br></pre></td></tr></table></figure><ul><li>handler可以是SIG_IGN, SIG_DFL。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(signo)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>kill向pid发送signo信号；</li><li>raise(signo) == kill(getpid(), signo);</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>seconds秒后产生SIGALRM信号；</li><li>一个进程只有一个alarm，之前的会被新的取代；</li><li>pause挂起进程直至捕捉到一个信号；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>前五个函数操纵信号集；</li><li>sigprocmask根据how(SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK)改变当前进程信号屏蔽字；</li><li>sigpending返回当前进程阻塞的信号集；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> struct sigaction *<span class="keyword">restrict</span> act,</span></span></span><br><span class="line"><span class="function"><span class="params">struct sigaction *<span class="keyword">restrict</span> oact)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span>      (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">sigset_t</span>  sa_mask;</span><br><span class="line">    <span class="keyword">int</span>       sa_flags;</span><br><span class="line">    <span class="keyword">void</span>      (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类似signal，但提供的功能更多；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> savesigs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>类似setjmp和longjmp, 但涉及到信号屏蔽字时，setjmp和longjmp不能正常工作，应该用sigsetjmp和siglongjmp函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>设置进程信号屏蔽字为sigmask，挂起进程，直至捕捉到一个信号并从信号处理程序返回，然后恢复信号屏蔽字，以上为原子操作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>相当于raise(SIGABRT);</li><li>abort绝不会返回，这意味着程序要么在SIGABRT处理函数中终止，要么之后在abort中终止。</li></ul><h3 id="信号名和编号转换"><a href="#信号名和编号转换" class="headerlink" title="信号名和编号转换"></a>信号名和编号转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psignal</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psiginfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">siginfo_t</span> *info, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strsignal</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sig2str</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">str2sig</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> *signop)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> APUE总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UNIX </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 信号 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>APUE-进程部分</title>
      <link href="/apue_process/"/>
      <url>/apue_process/</url>
      
        <content type="html"><![CDATA[<h2 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h2><h3 id="程序的启动"><a href="#程序的启动" class="headerlink" title="程序的启动"></a>程序的启动</h3><p>内核执行C程序时，先调用启动例程，然后可执行程序文件将启动例程设置为起始地址，启动例程然后从内核获得命令行参数和环境变量，类似下面这样调用main函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>(main(argc, argv));</span><br></pre></td></tr></table></figure><h3 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure><p>这三个函数的区别：</p><ul><li>exit()会对标准IO进行清洗，关闭所有IO流，并调用注册在atexit和on_exit里的函数（调用顺序与注册顺序相反，可以重复注册），然后调用_exit()。</li><li>_exit()直接返回内核，清理内存和进程。</li><li>_Exit()和_exit()等价，只不过前者是标准IO库里的，后者是系统调用。<a id="more"></a></li></ul><h3 id="C程序存储空间布局"><a href="#C程序存储空间布局" class="headerlink" title="C程序存储空间布局"></a><strong>C程序存储空间布局</strong></h3><p><img src="/apue_process/71.png" alt="典型布局"></p><ul><li>正文段(text)：机器指令部分，只读，存放在可执行文件中；</li><li>初始化数据段：包括了程序中已初始化好的全局变量或静态变量，存放在可执行文件中；</li><li>未初始化数据段(bss)：未初始化的全局变量或静态变量，exec时初始化为0，并不存放在磁盘上；</li><li>堆(heap)：动态分配区；</li><li>栈(stack)：局部变量和函数调用区；</li><li>命令行参数和环境变量；</li><li>栈向低地址增长，堆向高地址增长，如图可知，这样能解决堆和栈大小问题，最大化利用空间。</li></ul><h3 id="存储空间动态分配"><a href="#存储空间动态分配" class="headerlink" title="存储空间动态分配"></a>存储空间动态分配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nobj, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> newsize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>全局变量environ是环境变量表，可直接访问此数组或者用getenv()，putenv()，setenv()，unsetenv()来访问和修改环境变量。</p><p>修改环境表时，删除不会有什么问题，但添加和修改的话，因为环境表是放在进程地址空间的顶部的，低地址又是栈空间，大小无法改变，这时就需要堆中的空间了。</p><h3 id="非局部跳转"><a href="#非局部跳转" class="headerlink" title="非局部跳转"></a>非局部跳转</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个函数可以保存和恢复栈中信息来达到局部跳转的作用，但要注意，自动变量和寄存器变量的值在调用longjmp后是不确定的，定义volatile属性可以解决这个问题。</p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a><strong>fork</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><ul><li>fork函数调用一次，返回两次：<ul><li>父进程返回值为子进程PID；</li><li>子进程返回值为0；</li></ul></li><li>子进程基本是父进程的副本，数据空间，堆，栈全部复制，仅共享正文段；</li><li>为了性能，有写时复制技术；</li><li>子进程中的文件描述符和父进程共享文件表项，类似dup；</li><li>子进程不继承文件锁，未处理闹钟清空，未处理信号集设为空集；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> vfork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><ul><li>vfork创建的新进程目的是exec一个新程序；</li><li>子进程不完全复制父进程，在exec前共享父进程空间；</li><li>可以提高效率，但一定不要修改数据；</li><li>vfork保证子进程优先运行；</li></ul><h3 id="孤儿进程和僵死进程"><a href="#孤儿进程和僵死进程" class="headerlink" title="孤儿进程和僵死进程"></a>孤儿进程和僵死进程</h3><ul><li>子进程终止后，会留下一些信息(pid, 终止状态, cpu时间等)，父进程调用wait或waitpid可以得到这些信息，在父进程还没有wait之前，这些终止的进程就称为僵死进程；</li><li>如果子进程的父进程没有wait就终止，活动的子进程就变为孤儿进程，被init收养；</li><li>僵死进程会占用空间，对系统有害；</li><li>init一定会wait子进程，因此处理僵死进程的一个办法是kill掉他的父进程；</li><li>如果一个进程fork一个子进程，既不希望它等待子进程，也不希望子进程僵死至父进程终止的话，可以fork两次，第一次fork的子进程直接终止，使父进程不用等待子进程终止，也使真正的子进程成为孤儿进程，防止其长时间僵死。</li></ul><h3 id="wait和waitpid"><a href="#wait和waitpid" class="headerlink" title="wait和waitpid"></a><strong>wait和waitpid</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc);</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure><ul><li>wait阻塞直至有一个子进程终止，没有子进程则出错返回；</li><li>对于waitpid：<ul><li>pid == -1：和wait等价；</li><li>pid > 0：等待进程ID等于pid的子进程；</li><li>pid == 0：等待组ID等于调用进程组ID的任一子进程；</li><li>pid \&lt; -1：等待组ID等于pid绝对值的任一子进程；</li><li>WNOHANG选项提供非阻塞wait；</li></ul></li><li>还有waitid, wait3和wait4函数，提供了一些附加参数。</li></ul><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a><strong>exec</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char *) NULL, char *const envp[] */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><ul><li>l:list, v:vector, e:envp, p:PATH, f:fd；</li><li>file是在PATH环境变量目录中找可执行文件；</li><li>执行exec后，新程序继承文件锁、信号屏蔽字、未处理信号、资源限制等，文件描述符取决于FD_CLOEXEC标志是否打开；</li><li>以上exec的关系如图：<br>  <img src="/apue_process/81.png" alt="exec关系"></li></ul><h3 id="更改用户ID相关的函数"><a href="#更改用户ID相关的函数" class="headerlink" title="更改用户ID相关的函数"></a>更改用户ID相关的函数</h3><p><img src="/apue_process/82.png" alt="更改用户ID相关的函数"></p><h3 id="解释器文件"><a href="#解释器文件" class="headerlink" title="解释器文件"></a>解释器文件</h3><p>解释器文件是文本文件，第一行是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#! pathname [optional-argument]</span><br></pre></td></tr></table></figure><p>内核exec的是pathname指向的文件，然后用此程序解释文件剩下的内容。</p><h3 id="system函数"><a href="#system函数" class="headerlink" title="system函数"></a>system函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>执行cmdstring命令；</li><li>实现大概是fork，execshell程序，waitpid；</li></ul><h2 id="进程关系"><a href="#进程关系" class="headerlink" title="进程关系"></a>进程关系</h2><h3 id="终端登录"><a href="#终端登录" class="headerlink" title="终端登录"></a>终端登录</h3><p><img src="/apue_process/91.png" alt="登录流程"></p><p><img src="/apue_process/92.png" alt="登陆之后的设置"></p><h3 id="进程关系-1"><a href="#进程关系-1" class="headerlink" title="进程关系"></a>进程关系</h3><ul><li>进程组：一个或多个进程的集合，有一个组长进程，组长进程的PID就是GID。</li><li>孤儿进程组：进程组内每个成员的父进程要么是组内成员，要么不是该组所属会话的成员。</li><li><p>会话：一个或多个进程组的集合，可以将会话首进程的PID视为SID。</p><ul><li>会话可以有一个控制终端；</li><li>与控制终端建立连接的会话首进程成为控制进程；</li><li>会话中的进程组可分为一个前台进程组和一个或多个后台进程组；</li><li><p>以上特性如图：</p><p>  <img src="/apue_process/93.png" alt=""></p></li></ul></li></ul><h3 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h3><p><img src="/apue_process/94.png" alt=""></p><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>守护进程没有控制终端，通常常驻系统后台。</p><h3 id="如何编写守护进程"><a href="#如何编写守护进程" class="headerlink" title="如何编写守护进程"></a>如何编写守护进程</h3><ul><li>调用umask将文件创建屏蔽字设置为某个特定值；</li><li>调用fork，父进程exit，保证子进程不是组长进程；</li><li>调用setsid，创建新会话；</li><li>再次fork，防止子进程获得控制终端；</li><li>更改工作目录，关闭不需要文件描述符；</li><li>在0, 1, 2上打开/dev/null防止使用这些描述符的函数出错。</li></ul><h3 id="守护进程日志信息"><a href="#守护进程日志信息" class="headerlink" title="守护进程日志信息"></a>守护进程日志信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ident, <span class="keyword">int</span> option, <span class="keyword">int</span> facility)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> maskpri)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="守护进程惯例"><a href="#守护进程惯例" class="headerlink" title="守护进程惯例"></a>守护进程惯例</h3><ul><li>为了保证只有一个守护进程实例运行，可能使用锁文件，该文件通常命名为name.pid存储在/var/run目录下，内容是守护进程pid；</li><li>守护创建配置文件命名为name.conf放在/etc目录下；</li><li>既然守护进程没有控制终端，那么可以利用SIGHUP来进行某些操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> APUE总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UNIX </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>APUE-文件部分</title>
      <link href="/apue_file/"/>
      <url>/apue_file/</url>
      
        <content type="html"><![CDATA[<h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h2><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回的文件描述符一定是最小的未用描述符数值</span></span><br><span class="line"><span class="comment">// at函数从fd相对路径打开文件</span></span><br><span class="line"><span class="comment">// at函数可避免TOCTTOU错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ...)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 等同于open(path, O_WRONLY|O_CREAT|O_TRUNC, mode);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭文件的同时会释放文件上的所有记录锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文件偏移量，只更改偏移量，不引起I/O操作</span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回读/写字节数</span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于先lseek后read/write，但是是原子操作</span></span><br><span class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</span><br><span class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a><strong>文件共享</strong></h3><p>内核使用三种数据结构表示打开文件：</p><ol><li>进程表中的每一个进程都有一个记录项，这个记录项中有一张打开文件描述符表，每个文件描述符占用一项；</li><li>内核为所有打开的文件维护一张打开文件表，其中包含：<ul><li>文件状态标志；</li><li>当前文件偏移量；</li><li>指向v节点的指针；</li></ul></li><li>每个打开文件都有一个v节点，v节点包含了文件的一系列信息，直接和硬盘上的数据相关；</li></ol><p><img src="/apue_file/31.png" alt="一个进程打开两个文件"></p><p><img src="/apue_file/32.png" alt="两个进程打开同一个文件"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制一个现有的文件描述符</span></span><br><span class="line"><span class="comment">// dup返回当前可用的最小数值描述符</span></span><br><span class="line"><span class="comment">// dup2保证返回的描述符是fd2的数值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/apue_file/33.png" alt="dup后的内核数据结构"></p><h3 id="刷新缓冲区"><a href="#刷新缓冲区" class="headerlink" title="刷新缓冲区"></a>刷新缓冲区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将缓冲区排入写队列，不等待实际IO完成就返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似sync，但实际IO完成才返回</span></span><br><span class="line"><span class="comment">// 保证数据一定写到了硬盘上</span></span><br><span class="line"><span class="comment">// 更新文件的数据和属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 类似fsync，但只更新文件数据部分</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改变打开文件的属性：</span></span><br><span class="line"><span class="comment">// 复制已有描述符(F_DUPFD)</span></span><br><span class="line"><span class="comment">// 获取/设置文件描述符标志(F_GETFDM, F_SETFD)</span></span><br><span class="line"><span class="comment">// 获取/设置文件状态标志(F_GETFL, F_SETFL)</span></span><br><span class="line"><span class="comment">// 获取/设置异步I/O所有权(F_GETOWN, F_SETOWN)</span></span><br><span class="line"><span class="comment">// 获取/设置记录锁(F_GETLK, F_SETLK)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 杂项IO操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> request, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>关于/dev/fd：打开/dev/fd/n等同复制描述符n，类似dup。</p><p>如果使用追加标志打开了一个文件用来读写，lseek是有效的，因此可以从任何位置读，但写时，由于追加标志，文件偏移量会自动变为文件尾，无法在任何位置写:(</p><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ul><li>普通文件</li><li>目录文件</li><li>块特殊文件</li><li>字符特殊文件</li><li>FIFO</li><li>套接字</li><li>符号链接</li></ul><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>设置用户ID和设置组ID：通常执行程序文件时，进程有效UID就是实际UID，但如果设置了<em>设置用户ID位</em>，进程的有效UID会变为文件所有者的UID，这可以让普通用户也可以运行需要root权限的程序，设置组ID同理。</p><p>文件权限：</p><ul><li>用户(U)rwx，组(G)rwx，其他(O)rwx；</li><li>目录的r权限允许获取目录中所有文件的列表，目录的x权限允许搜索目录，于是目录的x位又称搜索位；</li><li>进程访问文件进行访问权限测试时，按照 超级用户-&gt;UID-&gt;GID-&gt;其他 的顺序检查，任何一项满足则停止检查；</li></ul><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p><img src="/apue_file/41.png" alt="磁盘、分区和文件系统"></p><p><img src="/apue_file/42.png" alt="详细柱面信息"></p><ul><li>目录项中包括文件名，i节点编号；</li><li>i节点中包括除了文件名和i节点编号的所有文件信息；</li><li>每个i节点都有一个链接计数，这就是硬链接的个数；</li><li>软链接是一种文件，占用一个数据块，类似win快捷方式；</li><li>由于两个文件系统i节点编号不唯一，可知硬链接不能跨文件系统；</li><li>同一文件系统下移动重命名只需改变目录项即可，原文件i节点编号不改变；</li><li>只有当i节点链接计数为0且无进程打开这个文件时，i节点数据才会被释放；</li></ul>]]></content>
      
      
      <categories>
          
          <category> APUE总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UNIX </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 文件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UNP-网络编程进阶</title>
      <link href="/unp_note_2/"/>
      <url>/unp_note_2/</url>
      
        <content type="html"><![CDATA[<h2 id="第十二章-IPv4和IPv6"><a href="#第十二章-IPv4和IPv6" class="headerlink" title="第十二章 IPv4和IPv6"></a>第十二章 IPv4和IPv6</h2><p>一图解释：</p><p><img src="/unp_note_2/1.png" alt=""></p><h2 id="第十三章-守护进程和inetd"><a href="#第十三章-守护进程和inetd" class="headerlink" title="第十三章 守护进程和inetd"></a>第十三章 守护进程和inetd</h2><p>守护进程：在后台运行且不与任何终端关联的进程。</p><p>syslogd：这个守护进程创建Unix域数据报套接字绑定/dev/log，等待接受日志信息，不过推荐使用syslog函数。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span> *message, ...)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>priority是以下两者位或：</p><p><img src="/unp_note_2/2.png" alt=""><br><img src="/unp_note_2/3.png" alt=""></p></li><li><p>message类似printf。</p></li></ul><p>关于daemon_init：</p><ul><li>fork，保证子进程后台运行且不是一个进程组的头进程；</li><li>setsid，子进程变成新会话和新进程组的头进程；</li><li>fork，保证子进程不会获得控制终端；</li><li>更改目录，关闭描述符，重定向描述符；</li><li>用syslogd处理错误。</li></ul><p>关于inetd：</p><ul><li>简化部分守护进程的编写；</li><li>单个进程取代每个服务一个进程，减少了进程总数；</li><li>读取/etc/inetd.conf配置；</li><li><img src="/unp_note_2/4.png" alt=""></li></ul><h2 id="第十四章-高级I-O函数"><a href="#第十四章-高级I-O函数" class="headerlink" title="第十四章 高级I/O函数"></a>第十四章 高级I/O函数</h2><h3 id="如何设置I-O超时？"><a href="#如何设置I-O超时？" class="headerlink" title="如何设置I/O超时？"></a>如何设置I/O超时？</h3><ol><li>调用alarm，通过SIGALRM中断系统调用；</li><li>使用select提供的超时机制等待I/O，用于connect时要求非阻塞；</li><li>使用SO_RCVTIMEO, SO_SNDTIMEO套接字选项。</li></ol><h3 id="recv和send"><a href="#recv和send" class="headerlink" title="recv和send"></a>recv和send</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> recv(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="keyword">ssize_t</span> send(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure><p>比起read和write区别在flags上，如下：</p><p><img src="/unp_note_2/5.png" alt=""></p><h3 id="readv和writev"><a href="#readv和writev" class="headerlink" title="readv和writev"></a>readv和writev</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span>  readv(<span class="keyword">int</span> filedes, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</span><br><span class="line"><span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> filedes, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span>    *iov_base;</span><br><span class="line">    <span class="keyword">size_t</span>   iov_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分散读和集中写，iov是指向struct iovec的一个数组。</p><h3 id="recvmsg和sendmsg"><a href="#recvmsg和sendmsg" class="headerlink" title="recvmsg和sendmsg"></a>recvmsg和sendmsg</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> recvmsg(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="keyword">ssize_t</span> sendmsg(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span>           *msg_name;</span><br><span class="line">    <span class="keyword">socklen_t</span>      msg_namelen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>   *<span class="title">msg_iov</span>;</span></span><br><span class="line">    <span class="keyword">int</span>            msg_iovlen;</span><br><span class="line">    <span class="keyword">void</span>           *msg_control;</span><br><span class="line">    <span class="keyword">socklen_t</span>      msg_controllen;</span><br><span class="line">    <span class="keyword">int</span>            msg_flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>msg_name, msg_namelen类似recvfrom, sendto的第五、六个参数；</li><li>msg_iov, msg_iovlen类似readv, writev的第二、三个参数；</li><li>区别flags和msg_flags，两者在接受和发送中有所不同；</li></ul><h3 id="辅助数据"><a href="#辅助数据" class="headerlink" title="辅助数据"></a>辅助数据</h3><p>利用sendmsg, recvmsg中msghdr的msg_control, msg_controllen发送接受。</p><h2 id="第十五章-Unix域协议"><a href="#第十五章-Unix域协议" class="headerlink" title="第十五章 Unix域协议"></a>第十五章 Unix域协议</h2><p>Why use it?</p><ul><li>同一主机上比TCP快；</li><li>能传递描述符；</li><li>能提供额外的安全检查；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span>&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>  sun_family; <span class="comment">//AF_LOCAL</span></span><br><span class="line">    <span class="keyword">char</span>         sun_path[<span class="number">104</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>路径必须是绝对路径名</strong>；</li><li>connect连接的路径名必须满足：<ul><li>存在该路径名；</li><li>必须是一个套接字；</li><li>有与之关联的打开的描述符；</li><li>类型相符合；</li></ul></li><li>connect发现监听套接字队列满直接返回ECONNREFUSED错误，不会像TCP一样重试；</li><li>发送数据报必须手动绑定路径名，系统不会自动绑定路径名，否则接收端无法应答；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建两个连接的套接字，仅适用于Unix域套接字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sockfd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>描述符传递：</p><ol><li>创建Unix域套接字；</li><li>发送进程创建msghdr，在其中填上描述符，发送；</li><li>接受进程利用recvmsg接受描述符；</li></ol><p><strong>注意，描述符传递并不是传递描述符数值，而是在发送过程中创建一个新的描述符，这个新的描述符引用相同的文件表项，新描述符的数值和发送描述符数值没有任何关系。</strong></p><h2 id="第十六章-非阻塞I-O"><a href="#第十六章-非阻塞I-O" class="headerlink" title="第十六章 非阻塞I/O"></a>第十六章 非阻塞I/O</h2><p>将一个套接字设置为非阻塞后，对其调用read, readv, recv, recvfrom, recvmsg, write, writev, send, sendto, sendmsg, accept若无法满足条件，进程不会睡眠，而是调用会返回一个EWOULDBLOCK，对于connect来说，连接通常无法立刻建立，但会激发三次握手，返回EINPROGRESS。</p><p>使用方法通常如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = fcntl(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">fcntl(fd, F_SETFL, val | O_NONBLOCK);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span>( (n = func(fd, buff, bufflen)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(errno == EWOULDBLOCK)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非阻塞connect："><a href="#非阻塞connect：" class="headerlink" title="非阻塞connect："></a>非阻塞connect：</h3><p>用途：</p><ul><li>将三次握手的时间利用起来；</li><li>同时建立多个连接；</li><li>利用select缩短connect的超时；</li></ul><p>注意：</p><ul><li>非阻塞connect通常无法立刻完成，返回EINPROGRESS，但若是同一主机，连接通常立刻完成。</li><li>利用select如何判断connect成功是个问题：<ul><li>套接字可写不可读意味着connect成功；</li><li>套接字可读可写意味着发生错误或者<strong>连接成功且对端已发送数据，应当再判断一下errno。</strong></li><li>移植问题（这里不考虑</li></ul></li><li>如果非阻塞connect可能被中断，且connect不被重启，此时只能使用select判断connect是否成功，因为我们不能再次调用connect。</li></ul><h3 id="非阻塞accept："><a href="#非阻塞accept：" class="headerlink" title="非阻塞accept："></a>非阻塞accept：</h3><p>若用select检测监听套接字的可读性(是否可accept)，既然select返回的是监听套接字可读，那么accept就不可能阻塞吗？答案是否定的，<strong>如果在select返回和accept之间客户发送RST终止连接，则连接被移除已连接队列，这时服务器调用accept就会阻塞，为了避免这个问题，就应当在select之前把监听套接字设为非阻塞，并在之后的调用中注意这一点。</strong></p><h2 id="第十七章-ioctl"><a href="#第十七章-ioctl" class="headerlink" title="第十七章 ioctl"></a>第十七章 ioctl</h2><p>ioctl是对设备I/O通道进行控制的函数。</p><h2 id="第十八章-路由套接字"><a href="#第十八章-路由套接字" class="headerlink" title="第十八章 路由套接字"></a>第十八章 路由套接字</h2><p>路由套接字可以管理路由表、接口列表，获取相关信息。</p><h2 id="第二十章-广播"><a href="#第二十章-广播" class="headerlink" title="第二十章 广播"></a>第二十章 广播</h2><p>竞争状态的相关思考：</p><ul><li>如果有多个进程访问共享数据，结果取决于进程的执行顺序，那么此时竞争问题就会出现；</li></ul><h2 id="第二十二章-高级UDP编程"><a href="#第二十二章-高级UDP编程" class="headerlink" title="第二十二章 高级UDP编程"></a>第二十二章 高级UDP编程</h2><ul><li>只有UDP支持广播和多播；</li><li>UDP连接成本小；</li><li>UDP不可靠，无流量控制；</li><li>简单请求和应答可以使用UDP，但应用程序应当自行错误检测；</li></ul><h3 id="UDP的可靠性"><a href="#UDP的可靠性" class="headerlink" title="UDP的可靠性"></a>UDP的可靠性</h3><ul><li>超时和重传</li><li>序列号</li></ul><h3 id="并发UDP服务器"><a href="#并发UDP服务器" class="headerlink" title="并发UDP服务器"></a>并发UDP服务器</h3><ul><li>如果UDP只发送一个应答，简单fork让子进程处理客户就好。</li><li>如果UDP和客户交换多个数据报，由于客户只知道服务器的众所周知端口，当主进程接受到一个数据报时不好判断数据报的来源，此时的解决办法是为每个客户创建一个新的套接字，并让客户将之后的数据包发送至这个新的套接字。</li></ul><h2 id="第二十四章-带外数据"><a href="#第二十四章-带外数据" class="headerlink" title="第二十四章 带外数据"></a>第二十四章 带外数据</h2><p>TCP并没有真正的带外数据，不过提供了紧急模式，一些注意点：</p><ul><li>收到的TCP首部虽然指出发送端进入紧急模式，但紧急指针指的数据却不一定已经发送；</li><li>即使因为流量控制暂停发送数据，紧急通知仍会发送；</li><li>每个连接只有一个带外标记，新到达的标记会覆盖之前的标记；</li><li>除非指定SO_OOBINLINE，新的带外字节会覆盖旧的带外字节；</li></ul><h2 id="第二十五章-信号驱动式I-O"><a href="#第二十五章-信号驱动式I-O" class="headerlink" title="第二十五章 信号驱动式I/O"></a>第二十五章 信号驱动式I/O</h2><ul><li>设置SIGIO信号的信号处理函数；</li><li>设置套接字属主(fcntl F_SETOWN)；</li><li>开启信号驱动式I/O(fcntl F_SETFL)；</li></ul><p>SIGIO信号的产生：</p><ul><li>对于UDP：<ul><li>数据报到达；</li><li>发生异步错误；</li></ul></li><li>对于TCP：<ul><li>监听套接字连接请求完成；</li><li>断连请求发起；</li><li>断连请求完成；</li><li>连接半关闭；</li><li>数据到达；</li><li>数据发送；</li><li>发生异步错误；</li></ul></li></ul><p>信号处理函数无法判断套接字的情况，于是信号式I/O对于TCP基本没用，UDP还有点用，不过只是一点。</p><h2 id="第二十六章-线程"><a href="#第二十六章-线程" class="headerlink" title="第二十六章 线程"></a>第二十六章 线程</h2><p>线程可以理解为轻量进程，同一进程有多个线程，这些线程共享全局内存，也就是共享全局变量、描述符、信号处理函数、工作目录，但每个线程有各自的TID、寄存器、栈、errno、优先级。</p><h3 id="创建和终止"><a href="#创建和终止" class="headerlink" title="创建和终止"></a>创建和终止</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似fork，attr是线程属性，func是函数指针，arg是函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *tid, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line">            void *(*func)(void *), void *arg);</span><br><span class="line"><span class="comment">//类似waitpid</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> *tid, <span class="keyword">void</span> **status)</span></span>;</span><br><span class="line"><span class="comment">//类似getpid</span></span><br><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">//使线程脱离，类似守护进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br><span class="line"><span class="comment">//终止线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *status)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="线程特定数据"><a href="#线程特定数据" class="headerlink" title="线程特定数据"></a>线程特定数据</h3><ul><li><p>每个线程支持有限数量的线程特定数据：</p><p>  <img src="/unp_note_2/6.png" alt=""></p></li><li><p>调用pthread_key_create创建一个键，并指定析构函数；</p></li><li><p>调用pthread_getspecific获取特定线程的键值(指针)；</p><p>  <img src="/unp_note_2/7.png" alt=""></p></li><li><p>分配所需内存，并将内存地址赋给指针；</p><p>  <img src="/unp_note_2/8.png" alt=""></p></li><li><p>线程终止时，扫描pkey数组，为非空元素调用key数组中相对应的析构函数；</p></li></ul><h3 id="互斥锁和条件变量"><a href="#互斥锁和条件变量" class="headerlink" title="互斥锁和条件变量"></a>互斥锁和条件变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">phtread_mutex_t</span> *mptr, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destory</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mptr)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">phtread_cond_t</span> *cptr, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destory</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cptr, <span class="keyword">pthread_mutex_t</span> *mptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cptr)</span></span>;</span><br></pre></td></tr></table></figure><p>为什么条件变量必须关联一个互斥锁：</p><ul><li>既然是条件变量，通常和一个变量有关，而这个变量肯定是共享的，因此这个变量肯定需要一个互斥锁；</li><li>wait函数是原子操作，当它阻塞时，必须要解锁这个互斥锁，如果不传给wait函数互斥锁自己手动解锁互斥锁，就不是原子操作了；</li></ul><h2 id="第二十八章-原始套接字"><a href="#第二十八章-原始套接字" class="headerlink" title="第二十八章 原始套接字"></a>第二十八章 原始套接字</h2><p>原始套接字可以直接读取ICMP分组，可以处理内核不处理的协议字段的数据报，还可以自己构造数据报。</p><h2 id="第三十章-C-S服务器程序设计范式"><a href="#第三十章-C-S服务器程序设计范式" class="headerlink" title="第三十章 C/S服务器程序设计范式"></a>第三十章 C/S服务器程序设计范式</h2><ul><li>迭代服务器</li><li>并发服务器<ul><li>多进程<ul><li>有进程池</li><li>无进程池</li></ul></li><li>多线程<ul><li>有线程池</li><li>无线程池</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> UNP总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UNIX </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UNP-网络编程基础</title>
      <link href="/unp_note_1/"/>
      <url>/unp_note_1/</url>
      
        <content type="html"><![CDATA[<p>既然意向是后台开发，理应看看网络编程相关的书籍，这方面经典书籍应该就是UNP了，花了一个多星期时间看完了前两部分，感觉上手不难，但是知识比较杂，底层API比较多，有很多坑要注意，所以先总结一下，注意，<strong>略过了SCTP相关内容</strong>。</p><h2 id="第一章-本书简介"><a href="#第一章-本书简介" class="headerlink" title="第一章 本书简介"></a>第一章 本书简介</h2><p>这一章简单介绍了一下网络编程，并用timeclient和timeserver程序引入了后面要讲的基本知识，然后介绍了一些历史和标准，本书的示例等等。  </p><p>值得学习的是包裹函数的思想，将可能发生错误的函数用另一个函数包起来，并在这个函数里处理那个函数可能发生的错误，可以一定程度上简化程序的编写，并且也有利于程序的维护。  </p><p>习题里提到一点，不同TCP对数据的处理是不同的，应当做好把数据看做字节流来处理的准备，直至到达数据流末尾。</p><a id="more"></a><h2 id="第二章-传输层介绍"><a href="#第二章-传输层介绍" class="headerlink" title="第二章 传输层介绍"></a>第二章 传输层介绍</h2><p>这一章讲了TCP/IP协议的相关内容，比较重要的是理解三次握手四次挥手的全过程，每个状态之间的转换以及存在的意义，注意TIME_WAIT存在的意义：</p><ul><li>可靠地实现TCP全双工连接的终止：被动关闭的一方可能收不到主动关闭一方最后发送的ACK，因此一定是主动关闭的一方需要TIME_WAIT，以便重传最后那个ACK。</li><li>让本连接的所有网络分节全部消逝：TIME_WAIT的时间是2MSL，这个时间里能保证当前连接的所有分组都被丢弃，这样建立新连接时，就不可能接受到前一个连接的重复分组了。</li></ul><p>随后是端口号，并发(fork相关)，缓冲区，常用网络服务与协议的关系。</p><p><img src="/unp_note_1/21.png" alt="三次握手和四次挥手"></p><p><img src="/unp_note_1/22.png" alt="状态转换图"></p><h2 id="第三章-套接字编程简介"><a href="#第三章-套接字编程简介" class="headerlink" title="第三章 套接字编程简介"></a>第三章 套接字编程简介</h2><p>这一章主要介绍的是套接字地址结构，字节排序函数，地址转换函数。</p><h3 id="地址结构："><a href="#地址结构：" class="headerlink" title="地址结构："></a>地址结构：</h3><ul><li><p>通用：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>        sa_len;     <span class="comment">// 并非所有系统都有</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    sa_family;  <span class="comment">// 协议族</span></span><br><span class="line">    <span class="keyword">char</span>           sa_data[<span class="number">14</span>];<span class="comment">// 特定协议族数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>IPv4：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span>                <span class="comment">// 这个结构是历史遗留问题 </span></span><br><span class="line">    <span class="keyword">in_addr_t</span>  s_addr;         <span class="comment">// 地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>        sin_len;    <span class="comment">// 并非所有系统都有</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    sin_family; <span class="comment">// 协议族</span></span><br><span class="line">    <span class="keyword">in_port_t</span>      sin_port;   <span class="comment">// 端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">// 地址结构</span></span><br><span class="line">    <span class="keyword">char</span>           sin_zero[<span class="number">8</span>];<span class="comment">// 填充struct sockaddr</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>IPv6：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span>&#123;</span>                  <span class="comment">// 这个结构是历史遗留问题 </span></span><br><span class="line">    <span class="keyword">unit8_t</span>  s6_addr[<span class="number">16</span>];          <span class="comment">// 地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         sin6_len;     <span class="comment">// 并非所有系统都有</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>     sin6_family;  <span class="comment">// 协议族</span></span><br><span class="line">    <span class="keyword">in_port_t</span>       sin6_port;    <span class="comment">// 端口号</span></span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_flowinfo;<span class="comment">// 流标字段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>    <span class="comment">// 地址结构</span></span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_scope_id;<span class="comment">// 范围</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>新通用：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         ss_len;        <span class="comment">// 并非所有系统都有</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>     ss_family;     <span class="comment">// 协议族</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//满足对齐要求并且足够大能容纳系统支持的任何套接字地址结构</span></span><br><span class="line">    <span class="comment">//对用户透明，我查看了我的系统，这部分是这样写的:</span></span><br><span class="line">    <span class="comment">// #define __ss_aligntype  unsigned long int</span></span><br><span class="line">    <span class="comment">// #define _SS_PADSIZE \</span></span><br><span class="line">    <span class="comment">//   (_SS_SIZE - __SOCKADDR_COMMON_SIZE - sizeof (__ss_aligntype))</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// struct sockaddr_storage&#123;</span></span><br><span class="line">    <span class="comment">//       __SOCKADDR_COMMON (ss_);    /* Address family, etc.  */</span></span><br><span class="line">    <span class="comment">//       char __ss_padding[_SS_PADSIZE];</span></span><br><span class="line">    <span class="comment">//       __ss_aligntype __ss_align;  /* Force desired alignment.  */</span></span><br><span class="line">    <span class="comment">//  &#125;;</span></span><br><span class="line">    <span class="comment">// 实际上__SOCKADDR_COMMON宏里只有一个family成员，</span></span><br><span class="line">    <span class="comment">// 也就是说我的系统并没有len这个成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>比较一下：<br><img src="/unp_note_1/31.png" alt="地址结构比较"></p><h3 id="值-结果参数："><a href="#值-结果参数：" class="headerlink" title="值-结果参数："></a>值-结果参数：</h3><p>就是传入当做值，传出当做结果的变量，因为需要更改变量，要传指针。</p><h3 id="字节排序函数："><a href="#字节排序函数：" class="headerlink" title="字节排序函数："></a>字节排序函数：</h3><p>注意小端字节序和大端字节序的区别，网络字节序总是大端字节序的，而主机字节序未知，所以需要字节排序函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h: host  n: network</span></span><br><span class="line"><span class="comment">// s: short l: long</span></span><br><span class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span>);</span><br><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span>);</span><br><span class="line"><span class="keyword">unit16_t</span> ntohs(<span class="keyword">uint16_t</span>);</span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span>);</span><br></pre></td></tr></table></figure><h3 id="字节操纵函数："><a href="#字节操纵函数：" class="headerlink" title="字节操纵函数："></a>字节操纵函数：</h3><p>和memset, memcpy, memcmp函数类似，<strong>两者参数顺序不同</strong>，<strong>请注意</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bcopy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">void</span> *dest, <span class="keyword">sizr_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="comment">// 相等返回1，否则非零</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bcmp</span><span class="params">(cont <span class="keyword">void</span> *ptr1, <span class="keyword">const</span> <span class="keyword">void</span> *ptr2, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="地址转换函数"><a href="#地址转换函数" class="headerlink" title="地址转换函数"></a>地址转换函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面三个函数只支持IPv4：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串有效返回1，否则0，结果存入addrptr指向结构中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *strptr, struct in_addr *addrptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 坑：出错返回INADDR_NONE，因此255.255.255.255不能由该函数处理，</span></span><br><span class="line"><span class="comment">// 然而这个函数已被废弃，不应使用</span></span><br><span class="line"><span class="keyword">in_addr_t</span> inet_addr(<span class="keyword">const</span> <span class="keyword">char</span> *strptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 坑：返回指向静态内存字符串的指针，不可重入，</span></span><br><span class="line"><span class="comment">// 并且参数不是指针是结构……</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr inaddr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两个函数IPv4, IPv6都支持，建议使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回1，str无效为0，出错为-1，addrptr指向in_addr或in6_addr结构</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> *strptr, <span class="keyword">void</span> *addrptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和上面那个相反，注意最后给出存储单元大小，防止溢出缓冲区，</span></span><br><span class="line"><span class="comment">// len太小返回空指针，并设置errno=ENOSPC，成功返回strptr</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">void</span> *addrptr, <span class="keyword">char</span> *strptr, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>本书为了使代码与协议无关，编写了sock_ntop等相关函数，封装了inet_ntop和inet_pton等转换函数，也方便了代码编写。</p><h3 id="read和write函数"><a href="#read和write函数" class="headerlink" title="read和write函数"></a>read和write函数</h3><p><strong>坑：read和write函数不同于文件I/O, 输入输出字节数可能比请求数量少，但这不是出错，是因为缓冲区满的问题，需要多次调用read和write函数直至完成。</strong> 为此本书编写了readn, writen, readline函数，然而从后面我们可以知道，readline函数要么调用很多次read导致速度很慢，要么使用缓冲区提高速度却增加了出现问题的可能（缓冲区是无法被select等函数所知道的，因此会一直阻塞）。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>仔细想想这些API，但凡涉及到指针的，大多都会多出一个参数要求你给出指针所指区域的大小，这是因为<strong>仅凭指针是无法获知指针所指区域的大小的，为了安全，你就必须给出大小</strong>，而有时候你又想要知道API究竟用了区域里多少空间，这时候就需要值-结果参数了。</p><h2 id="第四章-基本TCP套接字编程"><a href="#第四章-基本TCP套接字编程" class="headerlink" title="第四章 基本TCP套接字编程"></a>第四章 基本TCP套接字编程</h2><p><img src="/unp_note_1/41.png" alt="TCP套接字编程"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// family 协议族(AF_INET, AF_INET6, AF_LOCAL, AF_ROUTE, AF_KEY)</span></span><br><span class="line"><span class="comment">// type 套接字类型(SOCK_STREAM, SOCK_DGRAM, SOCK_SEQPACKET, SOCK_RAW)</span></span><br><span class="line"><span class="comment">// protocol 协议类型(IPPROTO_CP, IPPROTO_UDP, IPPROTO_SCTP, 0)</span></span><br><span class="line"><span class="comment">// family和type仅部分组合有效</span></span><br><span class="line"><span class="comment">// 创建套接字描述符</span></span><br><span class="line"><span class="comment">// 成功返回非负描述符，出错为-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有关端口：</span></span><br><span class="line"><span class="comment">// TCP客户通常无需绑定端口，connect时内核会选择临时端口</span></span><br><span class="line"><span class="comment">// TCP服务器通过周知端口被人连接，应绑定端口</span></span><br><span class="line"><span class="comment">// TCP服务器若不绑定，listen时内核选择临时端口</span></span><br><span class="line"><span class="comment">// 有关IP地址：</span></span><br><span class="line"><span class="comment">// TCP客户若绑定IP地址必须是所在主机网络接口之一，且指派了IP数据报源IP地址</span></span><br><span class="line"><span class="comment">// TCP客户若不绑定，则内核根据其外出网络接口自动绑定IP地址</span></span><br><span class="line"><span class="comment">// TCP服务器通常不绑定IP地址，内核将客户SYN的目的IP地址就作为服务器源IP地址</span></span><br><span class="line"><span class="comment">// TCP服务器若绑定，则意味着只接受目的IP地址为绑定IP地址的IP数据报（注意一下强端弱端系统模型）</span></span><br><span class="line"><span class="comment">// 成功返回0，出错为-1</span></span><br><span class="line"><span class="comment">// 坑：传递servaddr参数记得(struct sockaddr*)强制类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如之前说的，接受指针的函数通常需要一个长度参数</span></span><br><span class="line"><span class="comment">// 由TCP客户调用以连接TCP服务器</span></span><br><span class="line"><span class="comment">// 成功返回0，出错为-1</span></span><br><span class="line"><span class="comment">// 坑1：传递servaddr参数记得(struct sockaddr*)强制类型转换</span></span><br><span class="line"><span class="comment">// 坑2：connect失败后失败后sockfd不再可用，需close重新调用socket</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 套接字默认为主动，listen转换为被动，也就是从CLOSE转换到LISTEN</span></span><br><span class="line"><span class="comment">// backlog 套接字排队最大个数</span></span><br><span class="line"><span class="comment">// 一个监听套接字有两个队列：</span></span><br><span class="line"><span class="comment">//   1. 未完成连接队列：每项对应一个SYN分节，正在三次握手，处于SYN_RCVD状态</span></span><br><span class="line"><span class="comment">//   2. 已完成连接队列：完成三次握手的客户队列，处于ESTABLISHED状态</span></span><br><span class="line"><span class="comment">// 坑：不想让客户连接请关闭套接字，将backlog设为0是没用的</span></span><br><span class="line"><span class="comment">// 成功返回0，出错为-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由TCP服务器调用，从已完成连接队列头取下一个连接</span></span><br><span class="line"><span class="comment">// 坑1：传递cliaddr参数记得(struct sockaddr*)强制类型转换</span></span><br><span class="line"><span class="comment">// 坑2：addrlen是值-结果参数，记得传指针</span></span><br><span class="line"><span class="comment">// 对客户地址不感兴趣可设cliaddr和addrlen为NULL</span></span><br><span class="line"><span class="comment">// 成功返回非负描述符，出错为-1</span></span><br><span class="line"><span class="comment">// 坑3：回传的已连接描述符和之前的监听描述符不同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *cliaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 坑：描述符是引用计数的</span></span><br><span class="line"><span class="comment">// 成功返回0，错误为-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure><p>fork和exec函数准备看APUE深入了解，同时深入学习UNIX环境编程。</p><p>简单分清迭代和并发服务器。</p><p>知道这两个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取和某个套接字关联的本地地址或外地地址</span></span><br><span class="line"><span class="comment">// 成功返回0，错误为-1</span></span><br><span class="line"><span class="comment">// 坑：addrlen是值-结果参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *localaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *peeraddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="第五章-TCP程序示例"><a href="#第五章-TCP程序示例" class="headerlink" title="第五章 TCP程序示例"></a>第五章 TCP程序示例</h2><h3 id="服务器的编程大概是："><a href="#服务器的编程大概是：" class="headerlink" title="服务器的编程大概是："></a>服务器的编程大概是：</h3><ol><li>socket获取套接字</li><li>bzero, 并设置服务器sockaddr参数</li><li>bind sockaddr</li><li>listen</li><li>accept获取已连接套接字</li><li>处理客户请求</li></ol><h3 id="客户的编程大概是："><a href="#客户的编程大概是：" class="headerlink" title="客户的编程大概是："></a>客户的编程大概是：</h3><ol><li>socket获取套接字</li><li>bzero，并设置要连接的sockaddr参数</li><li>connect</li><li>和服务器交互</li></ol><h3 id="连接的正常关闭："><a href="#连接的正常关闭：" class="headerlink" title="连接的正常关闭："></a>连接的正常关闭：</h3><p>客户进程可以自己调用close(shutdown也可)将客户创建的套接字关闭或等自身被终止后由内核将客户创建的套接字关闭，然后客户TCP发送FIN至服务器，产生四次挥手的过程。</p><p>信号处理准备在APUE详细了解。</p><h3 id="子进程："><a href="#子进程：" class="headerlink" title="子进程："></a>子进程：</h3><p>子进程终止后会给父进程发送SIGCHLD信号并进入僵死状态，这是为了维护子进程的信息(PID, 终止状态，资源利用信息)供父进程使用，父进程必须调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回子进程PID, statloc指向子进程终止状态</span></span><br><span class="line"><span class="keyword">pid_t</span>  wait(<span class="keyword">int</span> *statloc);</span><br><span class="line"><span class="keyword">pid_t</span>  waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure><p><strong>坑：UNIX信号不排队，同时产生n个相同信号，对应的信号处理函数可能执行少于n次，那么在一个函数里调用单个wait可能无法正确处理子进程，正确做法应在循环里调用waitpid并指定WNOHANG使之在还有子进程运行时不阻塞，这里是无法调用wait的，因为如果有子进程仍在运行，你无法阻止wait阻塞。</strong></p><h3 id="慢系统调用："><a href="#慢系统调用：" class="headerlink" title="慢系统调用："></a>慢系统调用：</h3><p>指可能永远都阻塞的系统调用，注意，<strong>阻塞于慢系统调用时若被信号处理中断，此系统调用可能会返回EINTR错误，随后是坑：这个慢系统调用未必会自动重启，即使设置了SA_RESTART标志也未必（这个标志系统未必支持），那么如果保证移植性，请处理EINTR错误然后重启慢系统调用。</strong></p><h3 id="非正常连接终止"><a href="#非正常连接终止" class="headerlink" title="非正常连接终止"></a>非正常连接终止</h3><ol><li>三次握手完成后，在服务器accept前，客户发送RST，会导致accpet出错，错误如何处理依赖于不同的实现:(</li><li>服务器和客户建立连接后，若服务器进程终止，则服务器发送FIN到客户。</li><li>服务器和客户建立连接后，若服务器主机崩溃，有两种可能：<ol><li>服务器不重启，客户继续工作，就会发现对方没有回应(ETIMEOUT)，路由器聪明的话，则是目的地不可达(EHOSTUNREACH)。</li><li>服务器重启后，客户继续工作，然而服务器已丢失客户信息，收到客户数据后响应RST。</li></ol></li><li>服务器和客户建立连接后，若服务器关机，init进程会给所有进程发送SIGTERM信号预警，然后发送SIGKILL关闭所有其他进程，这样和2情况没什么差别。</li></ol><h3 id="SIGPIPE信号"><a href="#SIGPIPE信号" class="headerlink" title="SIGPIPE信号"></a>SIGPIPE信号</h3><p>向已收到RST的套接字写时会产生这个信号，默认终止进程。</p><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>跨越套接字传递二进制数据不好，因为主机字节序可能不同，解决方法：</p><ul><li>把所有数据作为文本串传送</li><li>显式定义二进制格式，遵循这个格式传送数据，RPC通常采用这个技术。</li></ul><h2 id="第六章-IO复用"><a href="#第六章-IO复用" class="headerlink" title="第六章 IO复用"></a>第六章 IO复用</h2><h3 id="IO模型："><a href="#IO模型：" class="headerlink" title="IO模型："></a>IO模型：</h3><ol><li>阻塞式IO：请求IO时进程阻塞，直至IO准备好。</li><li>非阻塞式IO：请求IO时，若IO将阻塞进程，不将进程投入睡眠，而是返回错误。</li><li>IO复用：进程可阻塞在多个系统调用上。</li><li>信号驱动式IO：IO准备好时内核发送SIGIO信号，进程不会阻塞。</li><li>异步IO：告知内核启动操作，并在内核完成后通知进程。</li></ol><p><img src="/unp_note_1/61.png" alt="IO模型比较"></p><h3 id="IO复用："><a href="#IO复用：" class="headerlink" title="IO复用："></a>IO复用：</h3><h4 id="select"><a href="#select" class="headerlink" title="select:"></a>select:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有描述符就绪返回其数目，超时为0，出错为-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset,</span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set *exceptset, <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>maxfdp1是待测试的<strong>最大描述符加1</strong>，描述符0,1,2…maxfdp1-1均被测试。</li><li>readset, writeset, exceptset分别是让内核测试读写异常条件的描述符集：<ul><li>用FD_ZERO(fd_set *fdset)宏 <strong>初始化</strong> 。</li><li><strong>一定要用FD_ZERO初始化描述符集</strong>。</li><li>FD_SET, FD_CLR设置要检查的描述符（位）。</li><li>FD_ISSET测试描述符是否满足条件。</li><li>这三个参数均为 <strong>值-结果参数</strong> ，<strong>每次重新调用select时，重新设置描述符。</strong></li><li><strong>每次重新调用select时，重新设置描述符。</strong></li></ul></li><li>timeout是超时：<ul><li>永远等待：设置为NULL。</li><li>等待一段时间：设置timeval结构并传递。</li><li>不等待：设置timeval为0，检查描述符后立刻返回（轮询）。</li></ul></li><li><strong>select有最大描述符限制</strong>，通常为1024（我的电脑是）。</li><li><p>描述符就绪条件:  </p><p><img src="/unp_note_1/62.png" alt="描述符就绪条件"></p></li></ul><h4 id="pselect"><a href="#pselect" class="headerlink" title="pselect:"></a>pselect:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有描述符就绪返回其数目，超时为0，出错为-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset,</span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set *exceptset, <span class="keyword">const</span> struct timespec *timeout</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br></pre></td></tr></table></figure><p>和select差别：</p><ol><li>使用timespec结构；</li><li>加了一个指向信号掩码的指针：没太看懂，需要看APUE。</li></ol><h4 id="poll"><a href="#poll" class="headerlink" title="poll:"></a>poll:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有描述符就绪返回其数目，超时为0，出错为-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fdarray, <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span>    fd;</span><br><span class="line">    <span class="keyword">short</span>  events;</span><br><span class="line">    <span class="keyword">short</span>  revents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>fdarray指向一个pollfd结构数组的第一个元素。</li><li><p>关于pollfd结构：</p><ul><li>fd设置描述符，设为-1表示忽略。</li><li><p>测试条件由events指出，描述符状态由revents返回：</p><p>  <img src="/unp_note_1/63.png" alt="测试条件"></p></li></ul></li><li><p>nfds是fdarray数组中元素个数。</p></li><li>timeout是单位为毫秒的正数：<ul><li>INFTIM：永远等待。</li><li>0：立刻返回，不阻塞进程。</li><li>>0：等待指定毫秒。</li></ul></li><li>poll没有select大小的限制。</li></ul><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll:"></a>epoll:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size仅提示内核所需的事件表大小，返回一个标识事件表的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// op 操作类型：EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL</span></span><br><span class="line"><span class="comment">// event 指定事件，结构体定义在下面</span></span><br><span class="line"><span class="comment">// 成功返回0，失败返回-1并设置errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line">    <span class="keyword">_uint32_t</span>    events; <span class="comment">// 事件类型</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;   <span class="comment">// 用户数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data&#123;</span><br><span class="line">    <span class="keyword">void</span>      *ptr;</span><br><span class="line">    <span class="keyword">int</span>       fd;</span><br><span class="line">    <span class="keyword">uint32_t</span>  u32;</span><br><span class="line">    <span class="keyword">uint64_t</span>  u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// events 指向存放所有就绪事件数组的指针</span></span><br><span class="line"><span class="comment">// maxevents 指定最多监听多少个事件，必须大于0</span></span><br><span class="line"><span class="comment">// timeout 与poll的timeout参数相同</span></span><br><span class="line"><span class="comment">// 成功返回就绪fd个数，失败返回-1并设置erro</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, </span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>epoll是Linux特有的IO复用，是用一组函数完成IO复用的。</p><ul><li>有关LT和ET模式：<ul><li>LT 水平触发，默认工作模式，也是select和poll的工作模式。一个事件就绪后，每次调用epoll_wait都会通知这个事件，直到这个事件被处理。</li><li>ET 边沿触发。一个事件就绪后，无论它是否被处理，epoll_wait仅通知一次这个事件，除非它再次就绪。</li><li>可看出ET能减少同一事件被触发的次数，效率高，但编程会复杂。</li><li><strong>使用ET模式的fd必须是非阻塞的。</strong></li><li>并发程序中，应当注册EPOLLONESHOT事件，防止一个socket同时被多个进程（线程）操作，然后在处理完后，则应重置EPOLLONESHOT事件。</li></ul></li></ul><h4 id="select-poll-epoll对比："><a href="#select-poll-epoll对比：" class="headerlink" title="select, poll, epoll对比："></a>select, poll, epoll对比：</h4><p><img src="/unp_note_1/64.png" alt="select, poll, epoll对比"></p><h3 id="shutdown："><a href="#shutdown：" class="headerlink" title="shutdown："></a>shutdown：</h3><h4 id="与close对比"><a href="#与close对比" class="headerlink" title="与close对比"></a>与close对比</h4><ol><li>close将描述符引用计数减一，直到0才关闭套接字。</li><li>close终止读写两个方向的连接，然而TCP是全双工的，即使停止写，不代表对方不发送数据，不代表自己不需要读。</li></ol><h4 id="有关howto"><a href="#有关howto" class="headerlink" title="有关howto"></a>有关howto</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功返回0，出错为-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>SHUT_RD：关闭读，并丢弃接受缓冲区所有数据，之后接受的任何数据都会被确认，但随即被静静丢弃。</li><li>SHUT_WR：关闭写，也就是半关闭，将发送缓冲区所有数据发送掉，然后发送TCP终止序列(FIN)。</li><li>SHUT_RDWR：和调用前面两个各一次一样。</li></ul><h3 id="其他坑点："><a href="#其他坑点：" class="headerlink" title="其他坑点："></a>其他坑点：</h3><ul><li>混合使用stdio和select很不好，因为select不知道stdio的缓冲区，它只从read或write等系统调用的角度指出是否可读可写。</li></ul><h2 id="第七章-套接字选项"><a href="#第七章-套接字选项" class="headerlink" title="第七章 套接字选项"></a>第七章 套接字选项</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功返回0，出错为-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>level: 指定解释选项的代码。</li><li>optname：选项名。</li><li>optval，opvlen：选项值，不同的选项数据类型不同。</li></ul><h3 id="有关选项"><a href="#有关选项" class="headerlink" title="有关选项"></a>有关选项</h3><p>分为两大基本类：</p><ul><li>二元标志选项：非0启用，0禁用。</li><li>值选项。</li></ul><h3 id="通用套接字选项-SOL-SOCKET"><a href="#通用套接字选项-SOL-SOCKET" class="headerlink" title="通用套接字选项 SOL_SOCKET"></a>通用套接字选项 SOL_SOCKET</h3><ul><li>SO_BROADCAST：广播选项。</li><li>SO_DEBUG：TCP支持，内核保留跟踪信息。</li><li>SO_DONTROUTE：绕过正常路由机制。</li><li>SO_ERROR：获取so_error值。</li><li><strong>SO_KEEPALIVE：TCP内置心跳机制。</strong></li><li><p><strong>SO_LINGER：指定close的操作：</strong></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>  l_onoff;</span><br><span class="line">    <span class="keyword">int</span>  l_linger;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>(l_onoff == 0)：close为默认设置，立刻返回。</p><p>  <img src="/unp_note_1/71.png" alt=""></p></li><li><p>(l_onoff != 0 &amp;&amp; l_linger == 0)：close时TCP直接发送RST终止连接。</p></li><li><p>(l_onoff != 0 &amp;&amp; l_linger != 0)：套接字关闭时，内核等待一段时间，直到发送缓冲区所有数据均发送并被确认或时间超时，这种时候<strong>一定要检查close的返回值，超时close返回EWOULDBLOCK错误且丢弃发送缓冲区残留数据。</strong></p><p>  <img src="/unp_note_1/72.png" alt=""><br>  <img src="/unp_note_1/73.png" alt=""></p></li><li><p><strong>注意：设置SO_LINGER后close成功返回只能表示发送的数据已被对端TCP确认，不能表示对端应用进程是否已读取数据，确认对端应用进程读取的方法：</strong></p><ul><li><p>调用shutdown(SHUT_WR)，等待对端的close：</p><p>  <img src="/unp_note_1/74.png" alt=""></p></li><li><p>使用应用级确认：</p><p>  <img src="/unp_note_1/75.png" alt=""></p></li></ul></li><li><p>shutdown和close比较： </p><p>  <img src="/unp_note_1/76.png" alt=""></p></li></ul></li><li><p>SO_OOBINLINE：带外数据留在正常输入队列中。</p></li><li><strong>SO_RCVBUF, SO_SNDBUF：发送(接受)缓冲区默认大小。坑：由于窗口大小是在连接时通过SYN分节交换，因此客户必须要在conncet前设置，服务器必须在listen前设置。</strong></li><li><strong>SO_RCVLOWAT, SO_SNDLOWAT：可读可写条件最低要求。</strong></li><li><strong>SO_RCVTIMEO, SO_SNDTIMEO：接受发送超时。</strong></li><li><strong>SO_REUSEADDR, SO_REUSEPORT：所有TCP服务器都应该在bind之前设置SO_REUSEADDR这个选项，以便重启服务器。</strong></li><li>SO_TYPE：返回套接字类型。</li><li>SO_USELOOPBACK：适用于路由套接字。</li></ul><h3 id="TCP套接字选项-IPPROTO-TCP"><a href="#TCP套接字选项-IPPROTO-TCP" class="headerlink" title="TCP套接字选项 IPPROTO_TCP"></a>TCP套接字选项 IPPROTO_TCP</h3><ul><li>TCP_MAXSEG：TCP最大分节大小(MSS)。</li><li><p>TCP_NODELAY：是否禁用Nagle算法：</p><ul><li><p>Nagle算法的目的是减少网络中的小分组，并常与ACK延迟算法联合使用，看图好理解：</p><p>  <img src="/unp_note_1/77.png" alt=""></p></li><li><p>对于服务器不在反方向产生数据或客户用若干小片数据向服务器发送逻辑请求的情况下，Nagle算法和ACK延迟算法不适合。解决方法：</p><ul><li>使用writev。</li><li>使用缓冲区，然后对缓冲区使用一次write。</li><li>设置这个选项，不推荐。</li></ul></li></ul></li></ul><h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功返回取决于cmd，出错为-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ...<span class="comment">/* int arg */</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启非阻塞IO</span></span><br><span class="line"><span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((flags = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">"F_GETFL error"</span>);</span><br><span class="line">flags |= O_NONBLOCK;</span><br><span class="line"><span class="keyword">if</span>(fcntl(fd, F_SETFL, flags) &lt; <span class="number">0</span> )</span><br><span class="line">    err_sys(<span class="string">"F_SETFL error"</span>);</span><br></pre></td></tr></table></figure><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ul><li><p><img src="/unp_note_1/78.png" alt=""></p><p>  第一个客户调用setsockopt, bind, connect, 如果第二个客户在第一个客户bind和connect之间调用bind, 那么返回EADDRINUSE错误，然而只要第一个客户连接上对端以后，第二个客户的bind就会正常工作，所以应该在第二个客户返回EADDRINUSE后多调用几次bind。</p></li></ul><h2 id="第八章-基本UDP套接字编程"><a href="#第八章-基本UDP套接字编程" class="headerlink" title="第八章 基本UDP套接字编程"></a>第八章 基本UDP套接字编程</h2><p><img src="/unp_note_1/81.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功返回读(写)的字节数，出错为-1</span></span><br><span class="line"><span class="comment">// buff, nbytes 读写缓冲区以及大小</span></span><br><span class="line"><span class="comment">// from 数据报源地址，注意addrlen是值-结果参数</span></span><br><span class="line"><span class="comment">// to   数据报目的地址，注意后面是个整数</span></span><br><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags,</span><br><span class="line">                struct sockaddr *from, <span class="keyword">socklen_t</span> *addrlen);</span><br><span class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags,</span><br><span class="line">               <span class="keyword">const</span> struct sockaddr *to, <span class="keyword">socklen_t</span> addrlen);</span><br></pre></td></tr></table></figure><ul><li><p>各种情况：</p><ul><li>数据报丢失：UDP数据包不可靠，很可能丢失。</li><li>验证响应：不能让所有知道客户端口号的进程都能向客户发送数据报，客户程序应对接收到的数据报的源地址进行验证。</li><li>服务器未运行：对一个UDP套接字，它引发的异步错误不会返回给它，除非它已连接。</li></ul></li><li><p>小总结：<br>  <img src="/unp_note_1/82.png" alt=""><br>  <img src="/unp_note_1/83.png" alt=""><br>  <img src="/unp_note_1/84.png" alt=""></p></li></ul><h3 id="关于connect函数"><a href="#关于connect函数" class="headerlink" title="关于connect函数"></a>关于connect函数</h3><p>connect后的UDP套接字有三个变化：</p><ol><li>写操作不能指定目的地址和端口了，因为connect时就已经确定。</li><li>读操作也不用获取源地址了，因为此时套接字只会接受connect指定地址的数据报。</li><li>异步错误会返回给它们所在的进程。</li></ol><p>如果多次调用connect：</p><ol><li>要么是指定新的目的地址和端口。</li><li>要么是要断开套接字(设置AF_UNSPEC)。</li></ol><p><strong>如果向同一目的地址发送数据报，已连接UDP套接字的性能要好于未连接UDP套接字。</strong></p><p><img src="/unp_note_1/85.png" alt=""></p><h3 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h3><ul><li>不论接受缓冲区接受到了多少数据，recvfrom永远都不会返回超过一个数据报的数据，这和TCP不同。</li></ul><h2 id="第十一章-名字地址转换"><a href="#第十一章-名字地址转换" class="headerlink" title="第十一章 名字地址转换"></a>第十一章 名字地址转换</h2><h3 id="关于DNS："><a href="#关于DNS：" class="headerlink" title="关于DNS："></a>关于DNS：</h3><p><img src="/unp_note_1/111.png" alt=""></p><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><h4 id="gethostbyname"><a href="#gethostbyname" class="headerlink" title="gethostbyname"></a>gethostbyname</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功为非空指针，出错为NULL并设置h_errno</span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *hostname)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>hostent结构：</p><p>  <img src="/unp_note_1/112.png" alt=""></p></li></ul><h4 id="gethostbyaddr"><a href="#gethostbyaddr" class="headerlink" title="gethostbyaddr"></a>gethostbyaddr</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功为非空指针，出错为NULL并设置h_errno</span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">socklen_t</span> len, <span class="keyword">int</span> family)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>通常关注h_name。</li><li>addr实际上是struct in_addr*类型。</li><li>family为AF_INET。</li><li>hostent结构和gethostbyname一样。</li></ul><h4 id="getservbyname-getservbyport"><a href="#getservbyname-getservbyport" class="headerlink" title="getservbyname, getservbyport"></a>getservbyname, getservbyport</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功为非空指针，出错为NULL并设置h_errno</span></span><br><span class="line"><span class="function">struct servent *<span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *servname, <span class="keyword">const</span> <span class="keyword">char</span> *protoname)</span></span>;</span><br><span class="line"><span class="function">struct servent *<span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *protoname)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>  *s_name;</span><br><span class="line">    <span class="keyword">char</span> **s_aliases;</span><br><span class="line">    <span class="keyword">int</span>    s_port;</span><br><span class="line">    <span class="keyword">char</span>  *s_proto;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>protoname可选，但注意有些端口(512, 513, 514)UDP和TCP提供的服务完全不同。</li><li><strong>s_port, port都是网络字节序，所有不要对s_port调用htons，而在传参时要对port调用htons。</strong></li></ul><h4 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功返回0，出错为非0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *hostname, <span class="keyword">const</span> <span class="keyword">char</span> *service,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct addrinfo *hints, struct addrinfo **result)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>hints填入期待返回类型的提示：<ul><li>ai_flags: AI_PASSIVE, AI_CANONNAME…</li><li>ai_family: AF_xxx</li><li>ai_socktype: SOCK_xxx</li><li>ai_protocol</li></ul></li><li><p>result指向一个指向addrinfo结构链表的指针：</p><p>  <img src="/unp_note_1/113.png" alt=""></p></li></ul><h4 id="gai-strerror"><a href="#gai-strerror" class="headerlink" title="gai_strerror"></a>gai_strerror</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回getaddrinfo返回的非0错误的含义</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">gai_strerror</span><span class="params">(<span class="keyword">int</span> error)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="freeaddrinfo"><a href="#freeaddrinfo" class="headerlink" title="freeaddrinfo"></a>freeaddrinfo</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getaddrinfo返回的链表是动态申请的</span></span><br><span class="line"><span class="comment">// ai指向第一个addrinfo结构，释放这个链表占用的堆内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo *ai)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功返回0，出错为非0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> struct sockaddr *sockaddr, <span class="keyword">socklen_t</span> addrlen,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">char</span> *host, <span class="keyword">socklen_t</span> hostlen,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">char</span> *serv, <span class="keyword">socklen_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sockaddr中包含待转换的协议地址。</li><li>host，serv需预先分配内存并提供长度参数。</li><li><p>关于flags：</p><p>  <img src="/unp_note_1/115.png" alt=""></p></li></ul><h3 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h3><p>记一下，inet_pton, inet_ntop, getaddrinfo, getnameinfo通常可重入。</p><p>不可重入的原因是使用了全局变量或静态变量。</p><p>关于gethostbyname_r和gethostbyaddr_r, 这个是平台依赖的，我使用时比较坑……建议使用getaddrinfo和getnameinfo代替。</p><h3 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a>其他</h3><p>网络相关信息有一系列函数：</p><p><img src="/unp_note_1/114.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> UNP总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UNIX </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vim命令整理</title>
      <link href="/vim_command/"/>
      <url>/vim_command/</url>
      
        <content type="html"><![CDATA[<p>开始接触Linux时便有听说vim，之后在学习Linux命令的过程中就把vim学了学，但是之后就没怎么用过vim了。直到前段时间学习shell脚本时，一直用vim在终端里写shell脚本，熟悉了一些基础的vim命令，感受到vim编辑代码的高效。</p><p>平心而论，我是懒得去把vim配置成IDE的，我还是离不开IDE的……不过在IDE中装个vim插件，同时享受vim编辑的高效和IDE的便捷，我觉得还是很好的，于是觉得自己该补补vim的命令了，特此整理：</p><p>vim有多种模式，默认进入是命令模式，之后按a,o,i,c,s等可以进入插入模式，或是按v进入可视模式。按ESC退出插入或可视模式，如果你不知道现在在干什么，按两下ESC能保证你退回到初始的命令模式。</p><a id="more"></a><p><strong>基本操作</strong>：</p><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">命令</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">:q</td><td style="text-align:center">退出</td><td style="text-align:center">quit</td></tr><tr><td style="text-align:center">:w</td><td style="text-align:center">保存文件</td><td style="text-align:center">write</td></tr><tr><td style="text-align:center">:wq</td><td style="text-align:center">保存并退出</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ZZ</td><td style="text-align:center">保存并退出</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">!*</td><td style="text-align:center">强制执行*命令</td><td style="text-align:center">比如不保存退出</td></tr></tbody></table><p><strong>移动操作</strong>：</p><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">命令</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">j,k,h,l</td><td style="text-align:center">上下左右移动光标</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ctrl+u</td><td style="text-align:center">上翻半页</td><td style="text-align:center">up</td></tr><tr><td style="text-align:center">ctrl+d</td><td style="text-align:center">下翻半页</td><td style="text-align:center">down</td></tr><tr><td style="text-align:center">ctrl+f</td><td style="text-align:center">上翻一页</td><td style="text-align:center">forward</td></tr><tr><td style="text-align:center">ctrl+b</td><td style="text-align:center">下翻一页</td><td style="text-align:center">backward</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">下一个词首</td><td style="text-align:center">word</td></tr><tr><td style="text-align:center">W</td><td style="text-align:center">同上，长跳</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">e</td><td style="text-align:center">词尾</td><td style="text-align:center">end</td></tr><tr><td style="text-align:center">E</td><td style="text-align:center">词尾，长跳</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">词首</td><td style="text-align:center">back</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">词首，长跳</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">行头</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">行首第一个非空字符</td><td style="text-align:center">正则表达式</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">行尾</td><td style="text-align:center">正则表达式</td></tr><tr><td style="text-align:center">gg</td><td style="text-align:center">第一行</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">G</td><td style="text-align:center">最后一行</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><em>G/</em>gg</td><td style="text-align:center">第*行</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">gd</td><td style="text-align:center">跳到光标所在变量的声明位置</td><td style="text-align:center">go define</td></tr><tr><td style="text-align:center">f*</td><td style="text-align:center">在当前行向后查找*字符，跳至此处</td><td style="text-align:center">find</td></tr><tr><td style="text-align:center">F*</td><td style="text-align:center">在当前行向前查找*字符，跳至此处</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">t*</td><td style="text-align:center">在当前行向后查找*字符，跳至此处之前</td><td style="text-align:center">to</td></tr><tr><td style="text-align:center">T*</td><td style="text-align:center">在当前行向前查找*字符，跳至此处之后</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">;</td><td style="text-align:center">重复上一个f<em>/F</em>/t<em>/T</em>命令</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">,</td><td style="text-align:center">反向重复上一个f<em>/F</em>/t<em>/T</em>命令</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">#</td><td style="text-align:center">向上查找光标所在单词</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">向下查找光标所在单词</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">查找匹配括号</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(</td><td style="text-align:center">上一个句子</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">)</td><td style="text-align:center">下一个句子</td></tr></tbody></table><p><strong>编辑操作</strong>：</p><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">命令</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:center">从当前光标插入编辑</td><td style="text-align:center">insert</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">从行首插入编辑</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">从当前光标后插入编辑</td><td style="text-align:center">add</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">从行尾插入编辑</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">光标下新加一行插入编辑</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">O</td><td style="text-align:center">光标上新加一行插入编辑</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Esc</td><td style="text-align:center">退回命令模式</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">dd</td><td style="text-align:center">删除光标行</td><td style="text-align:center">delete</td></tr><tr><td style="text-align:center">d*</td><td style="text-align:center">根据*的范围删除</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">删除从光标到行尾的字符</td><td style="text-align:center">d$</td></tr><tr><td style="text-align:center">cc</td><td style="text-align:center">删除光标行并插入</td><td style="text-align:center">clear</td></tr><tr><td style="text-align:center">c*</td><td style="text-align:center">根据*的范围删除并插入</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">删除从光标到行尾的字符并插入</td><td style="text-align:center">c$</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">删除光标下字符</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">删除光标前字符</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">删除光标下字符并插入</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">删除光标行并插入</td><td style="text-align:center">cc</td></tr><tr><td style="text-align:center">r</td><td style="text-align:center">替换光标下字符</td><td style="text-align:center">replace</td></tr><tr><td style="text-align:center">R</td><td style="text-align:center">进入替换模式</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">v</td><td style="text-align:center">进入可视模式</td><td style="text-align:center">visual</td></tr><tr><td style="text-align:center">J</td><td style="text-align:center">合并当前行和下一行</td><td style="text-align:center">join</td></tr><tr><td style="text-align:center">u</td><td style="text-align:center">撤销上一次编辑操作</td><td style="text-align:center">undo</td></tr><tr><td style="text-align:center">U</td><td style="text-align:center">撤销本行的所有编辑操作</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ctrl+r</td><td style="text-align:center">重做上次操作</td><td style="text-align:center">和u相反</td></tr></tbody></table><p><strong>复制粘贴操作</strong>：</p><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">命令</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">yy</td><td style="text-align:center">复制当前行</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">y*</td><td style="text-align:center">根据*的范围复制</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">在光标后粘贴</td><td style="text-align:center">paste</td></tr><tr><td style="text-align:center">P</td><td style="text-align:center">在光标前粘贴</td></tr></tbody></table><p>至于剪切，可以理解为每次删除都把删除的文本放入同一个剪切板，直接p就会把剪切板中的东西粘贴下来。</p><p><strong>查找操作</strong>：</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">/something</td><td style="text-align:center">在后面的文本中查找something</td></tr><tr><td style="text-align:center">?something</td><td style="text-align:center">在前面的文本中查找something</td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">下一个查找结果</td></tr><tr><td style="text-align:center">N</td><td style="text-align:center">前一个查找结果</td></tr></tbody></table><p><strong>替换操作</strong>：</p><p>:[range]s/old/new/[flags]</p><p>range:</p><ul><li>m,n:m到n行</li><li>$:最后一行</li><li>.:当前行</li><li>%:所有行</li><li>默认是当前行</li></ul><p>flags:</p><ul><li>c:替换前进行确认</li><li>g:替换一行中的所有匹配项，默认只替换第一个</li><li>i:忽略大小写</li><li>e:忽略错误</li></ul><p><strong>自定义操作</strong>：</p><p>:[range]g/pattern/commmand</p><p>对匹配到模式的行执行command命令</p><p><strong>其他操作</strong>：</p><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">命令</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">~</td><td style="text-align:center">大小写转换</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">zc</td><td style="text-align:center">关闭折叠块</td><td style="text-align:center">zip close</td></tr><tr><td style="text-align:center">zo</td><td style="text-align:center">打开折叠块</td><td style="text-align:center">zip open</td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">排版当前行</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\&lt;\&lt;</td><td style="text-align:center">左缩进</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:center">右缩进</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ctrl+a</td><td style="text-align:center">递增光标下数字</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ctrl+x</td><td style="text-align:center">递减光标下数字</td></tr></tbody></table><p><strong>使用窍门</strong>：</p><ul><li>大写通常是小写操作的加强或者相反操作</li><li>查找替换操作支持正则表达式</li><li>几乎所有编辑选择操作都可以在前面键入数字，来重复执行此命令n次</li><li>编辑相关操作可和选择操作结合，编辑指定区域</li><li>发挥你的想象，命令组合的自由性是vim的特色</li></ul><p>vim很强大，这里只列出了很小一部分的快捷键，而且因为我是在IDE中用vim，并没有考虑多文件编辑，多窗口分栏，终端交互等操作。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从零开始机器学习</title>
      <link href="/machine_learning_note/"/>
      <url>/machine_learning_note/</url>
      
        <content type="html"><![CDATA[<h2 id="机器学习的定义"><a href="#机器学习的定义" class="headerlink" title="机器学习的定义"></a>机器学习的定义</h2><p>作为机器学习领域的先驱，Arthur Samuel在 IBM Journal of Research and Development期刊上发表了一篇名为《Some Studies in Machine Learning Using the Game of Checkers》的论文中，将机器学习非正式定义为：“在不直接针对问题进行编程的情况下，赋予计算机学习能力的一个研究领域。”</p><p>而我认为机器学习是：我们在日常生活中，会遇到很多问题，大致分为两类，一类问题有确定的解法，比如说判断一个数是否是偶数，这种问题可以很清楚地用计算机编写程序并解决；另一类问题则没有固定的解法，比如说判断一个人说了什么，写了什么，因为这些问题的随机性很大，我们解决这些问题的方法，就是用大量的数据，采用一些训练方法，来训练计算机，使得计算机能够解决这些问题，而这个训练过程就称为机器学习。<br><a id="more"></a></p><h2 id="机器学习的范围"><a href="#机器学习的范围" class="headerlink" title="机器学习的范围"></a>机器学习的范围</h2><ul><li><strong>模式识别</strong>：模式识别≈机器学习。机器学习的目的就是为了模式识别。</li><li><strong>数据挖掘</strong>：数据挖掘=机器学习+数据库。数据挖掘是从大量的数据中挖掘出有用的价值，而机器学习的方法则可以用于进行数据挖掘。</li><li><strong>计算机视觉</strong>：计算机视觉=机器学习+图像处理。手写输入、图片识别在日常生活已经很常见，应用很广泛。</li><li><strong>语音识别</strong>：语音识别=机器学习+语音处理。听歌识曲、语音识别都是相关应用。</li><li><strong>自然语言处理</strong>：自然语言处理=机器学习+文本处理。自然语言处理方面，大量使用了编译原理相关的技术，而在自然语言理解方面，则使用了机器学习等技术。</li><li>等等……</li></ul><h2 id="机器学习的分类"><a href="#机器学习的分类" class="headerlink" title="机器学习的分类"></a>机器学习的分类</h2><p>机器学习大致可以分为<strong>监督学习</strong>、<strong>无监督学习</strong>、<strong>强化学习</strong>、<strong>迁移学习</strong>：</p><ul><li><strong>监督学习</strong>：利用一组已知类别的样本调整分类器的参数，使其达到所要求性能的过程。通俗来讲，就是让计算机做选择题，并<strong>提供了它们的正确答案</strong>，计算机努力调整自己的参数，最终让自己推测的答案与标准答案一致。</li><li><strong>无监督学习</strong>：根据类别未知(没有被标记)的训练样本解决模式识别中的各种问题，对训练样本进行建模，并进行归类。通俗来讲，就是让计算机做选择题，但<strong>并不提供正确答案</strong>，让计算机自己去分析这些题目之间的关系，并对这些题目进行分类，以后遇到新的问题就计算这个新问题的相似度，根据相似度来对新问题归类。</li><li><strong>强化学习</strong>：所谓强化学习就是智能系统从环境到行为映射的学习，以使奖励信号(强化信号)函数值最大，强化学习不同于连接主义学习中的监督学习，主要表现在教师信号上，强化学习中由环境提供的强化信号是对产生动作的好坏作一种评价(通常为标量信号)，而不是告诉强化学习系统RLS如何去产生正确的动作。通俗来讲，就是让计算机做选择题，但<strong>并不提供正确答案</strong>，在计算机做完这些题后，我们<strong>作为老师来批改计算机做的对不对</strong>，对的越多，奖励越多，计算机则努力调整自己的参数来得到更多的奖励，可以理解为先无监督后有监督学习。</li><li><strong>迁移学习</strong>：迁移学习顾名思义就是就是把已训练好的模型参数迁移到新的模型来帮助新模型训练。考虑到大部分数据或任务是存在相关性的，所以通过迁移学习我们可以将已经学到的模型参数（也可理解为模型学到的知识）通过某种方式来分享给新模型从而加快并优化模型的学习效率而不用像大多数网络那样从零学习。</li></ul><h2 id="机器学习的方法"><a href="#机器学习的方法" class="headerlink" title="机器学习的方法"></a>机器学习的方法</h2><ol><li><p><strong>回归算法</strong>：回归算法是通过一系列已知的自变量和因变量，建立变量之间的回归方程，并把回归方程作为算法模型来预测新自变量与因变量的关系。回归分为很多类型，这里介绍两种重要的类型：</p><ul><li><p>线性回归：线性回归用最佳的拟合直线来在因变量和一个或多个自变量之间建立一种关系，想要获得这条拟合直线，可以采用最小二乘法或梯度下降法。线性回归是人们常用的一种方法，它有一些注意点：</p><ul><li>自变量与因变量之间必须有线性关系。</li><li>多元回归存在多重共线性，自相关性和异方差性。</li><li>线性回归对异常值非常敏感，异常值会严重影响回归线，最终影响预测值。</li><li>多重共线性会增加系数估计值的方差，使得在模型轻微变化下，估计非常敏感。结果就是系数估计值不稳定。</li><li>在多个自变量的情况下，我们可以使用向前选择法，向后剔除法和逐步筛选法来选择最重要的自变量。</li></ul></li><li><p>逻辑回归：逻辑回归和线性回归很类似，但它和线性回归解决的问题类型不同。线性回归处理的是数值问题，最后得到的是数值，而逻辑回归属于分类算法，最后得到的是离散的分类。由于逻辑回归是分类算法，因此它广泛的用于分类问题，并且不要求自变量和因变量是线性关系，不过，它需要大量的样本，并且自变量不应该相互关联，不然会影响它的估计效果。</p><p>除了这两种，回归模型还有很多，我们在选择合适的回归模型时，应考虑一些因素：</p></li><li><p>数据是模型组成的必然部分，识别变量的关系和影响是很重要的。</p></li><li>比较各个模型的特点，分析它们之间的指标参数，检查你的模型中可能出现的偏差。</li><li>交叉验证是评估模型的最好方法，将你的数据分为两份，一份做训练，一份做验证，计算观测值和预测值的一个简单均方差来衡量你的预测精度。</li><li>选择模型也取决于你的目的，有时候，一个并不那么强大但容易实现的模型可能对你来说更好。</li></ul></li><li><p><strong>神经网络</strong>：神经网络算法是80年代机器学习界非常流行的算法，不过在90年代中途衰落。现在，借着“深度学习”的热度，神经网络重新成为最强大的机器学习算法之一。</p><p> 正如其名，神经网络的诞生源于对大脑工作原理的研究。科学家渴望利用机器模拟大脑，让机器也能思考，经过研究，他们发现人能思考的原因在于人体的神经网络，外部刺激通过神经末梢，转化为电信号，转导到神经元，无数神经元构成神经中枢，神经中枢综合各种信号，做出判断，进而人对外界刺激做出反应。</p><p> 在这个过程中，思考的基础是神经元，那么只要我们能够“人造”神经元，就可以模拟神经网络的思考了，而这个“人造神经元”模型，我们称为“感知器”。感知器简单来说，就是接受外部输入，并产生输出，外部输入决定着输出。外部输入是怎么决定输出的呢？可能会有多个外部输入，那么我们赋予每一个输入一个权重，根据权重和输入数据计算出一个结果，将这个结果和一个我们指定的阈值相比，他们之间的大小关系就决定了最后的输出。</p><p> 一个神经网络的搭建，需要满足三个条件：</p><ul><li>输入和输出</li><li>权重和阈值</li><li><p>多层感知器的结构</p><p>外界给神经网络输入，底层的感知器对外部输入做出判断后，将输出作为上层感知器的输入，直到得到最后的结果。在这个过程中，最困难的就是确定权重和阈值，这两个值通常很难估计，都是主观给出的，我们必须有一种方法来确定它们的值，这种办法就是试错法。</p><p>我们不改变其他的参数，每次只对权重和阈值进行微调，并观察输出的变化，直至得到对应最精确输出的那组权重和阈值，这个过程称为模型的训练。于是神经网络的运作过程如下：</p></li></ul><ol><li>确定输入和输出</li><li>找到一种或多种算法，可以从输入得到输出</li><li>找到一组已知答案的数据集，用来训练模型，估算权重和阈值</li><li><p>一旦新的数据产生，输入模型，就可以得到结果，同时对权重和阈值进行校正</p><p>可以看到，整个过程需要大量的计算，这也是直到近几年神经网络才火起来的原因，在原来的年代，硬件是没有这么强的计算力的。</p><p>神经网络在日常生活中有很多例子，语音识别，手写识别，车牌识别，图片识别都是通过输入语音，笔迹，车牌，图片，对它们的各个参数设置权重，再找到一种图片对比算法，声音对比算法作为感知器，最后得到一个概率来决定这个输入的最终结果是什么。我们可以用一组已经人为识别好的数据，来作为训练数据，不断调整参数，直到得到想要的模型，并且日后的新输入还可以对已有的模型进行校正。</p></li></ol></li><li><p><strong>SVM(支持向量机)</strong>：支持向量机算法是诞生于统计学习界，同时在机器学习界大放光彩的经典算法。从某种意义上来说，SVM是逻辑回归算法的强化，可以获得比逻辑回归更好的分类界线，这其中的关键就在于一个核函数。</p><p> 核函数，它可以将样本从原始空间映射到一个更高维的特质空间中，使得样本在这个新的高维空间中可以被线性划分为两类，即在空间内线性划分，划分后再将分割的超平面映射回去，就能得到非常复杂的分类界线，从而达成很好的的分类效果。</p></li><li><p><strong>聚类算法</strong>：聚类就是按照某个特定的标准把一个数据集分割为不同的类或簇，使得同一个簇内的数据对象的相似性尽可能大，同时不在同一个簇中的数据对象的差异性也尽可能地大。即聚类后同一类的数据尽可能聚集到一起，不同数据尽量分离。</p><p> 而聚类算法就是对那些无法明确数据分类的数据进行聚类，最后把相似的数据聚在一起，聚类算法不需要用训练数据进行学习，只需要一个可以计算相似度的算法就可以工作了，所以它属于无监督算法。</p><p> 聚类的过程大概如下：</p><ol><li>数据准备：包括特征标准化和降维</li><li>特征选择：从最初的特征中选择最有效的特征,并将其存储于向量中</li><li>特征提取：通过对所选择的特征进行转换形成新的突出特征</li><li>聚类：首先选择合适特征类型的某种距离函数进行接近程度的度量，而后执行聚类</li><li><p>结果评估：主要有3种，外部有效性评估、内部有效性评估和相关性测试评估</p><p>聚类的方法有以下几种：</p></li></ol><ul><li><p>基于层次的聚类：透过一种层次架构方式，反复将数据进行分裂或聚合，算法流程如下:</p><ol><li>将每个对象看作一类，计算两两之间的最小距离</li><li>将距离最小的两个类合并成一个新类</li><li>重新计算新类与所有类之间的距离</li><li><p>重复2、3，直到所有类最后合并成一类</p><p>这个算法的可解释性高，不过时间复杂度过高。</p></li></ol></li><li><p>基于划分的聚类：预先指定聚类数目或聚类中心，反复迭代逐步降低目标函数误差值直至收敛，得到最终结果，经典的K-means算法流程如下：</p><ol><li>随机地选择k个对象，每个对象初始地代表了一个簇的中心</li><li>对剩余的每个对象，根据其与各簇中心的距离，将它赋给最近的簇</li><li>重新计算每个簇的平均值，更新为新的簇中心</li><li><p>不断重复2、3，直到准则函数收敛</p><p>这个算法对于大型数据集简单高效，时间复杂度、空间复杂度低，但需要预先设定k值，对最先的k个点选取很敏感，且数据集大时结果容易局部最优。</p></li></ol></li><li><p>基于密度的聚类：只要邻近区域的密度（对象或数据点的数目）超过某个阈值，就继续聚类，DBSCAN算法的流程如下：</p><ol><li>从任一对象点p开始</li><li>寻找并合并核心p对象直接密度可达（eps）的对象</li><li>如果p是一个核心点，则找到了一个聚类，如果p是一个边界点（即从p没有密度可达的点）则寻找下一个对象点</li><li><p>重复2、3，直到所有点都被处理</p><p>这个算法对噪声不敏感；能发现任意形状的聚类，但聚类的结果与参数有很大的关系。</p></li></ol></li><li><p>基于网络的聚类：将数据空间划分为网格单元，将数据对象集映射到网格单元中，并计算每个单元的密度。根据预设的阈值判断每个网格单元是否为高密度单元，由邻近的稠密单元组形成”类“。算法的核心流程如下：</p><ol><li>划分网格 </li><li>使用网格单元内数据的统计信息对数据进行压缩表达 </li><li>基于这些统计信息判断高密度网格单元 </li><li><p>最后将相连的高密度网格单元识别为簇</p><p>这个算法速度很快，但参数敏感，无法处理不规则分布的数据。</p></li></ol></li><li><p>基于模型的聚类：为每簇假定了一个模型，寻找数据对给定模型的最佳拟合，同一“类”的数据属于同一种概率分布，即假设数据是根据潜在的概率分布生成的。算法流程如下：</p><ol><li>网络初始化，对输出层每个节点权重赋初值</li><li>将输入样本中随机选取输入向量，找到与输入向量距离最小的权重向量</li><li>定义获胜单元，在获胜单元的邻近区域调整权重使其向输入向量靠拢</li><li>提供新样本，进行训练</li><li><p>收缩邻域半径、减小学习率、重复，直到小于允许值，输出聚类结果</p><p>这个算法对”类“的划分不那么”坚硬“，而是以概率形式表现，但执行效率不高。</p></li></ol></li><li><p>还有一些其他的聚类方法，这里不做介绍。</p></li></ul></li><li><p><strong>降维算法</strong>：降维算法就是把数据从高维降低到低维层次，这里的维数就是数据特征量的数目，比如说一个盒子的属性有长、宽、高、表面积和体积，这是五维的数据，而我们知道，表面积和体积可以通过长宽高算出来，那么我们可以认为这里产生了数据冗余，我们可以把表面积和体积算出来，从而将五维压缩至三维。另外，我们这里进行的是无损压缩，因为数据是冗余的，而在实际的降维中，可能会导致数据的损失，但这些数据并不是白白损失了，通过降维，我们可以压缩数据与提升机器学习其他算法的效率。降维算法主要有四种：</p><ul><li>Principal Component Analysis</li><li>Linear Discriminant Analysis</li><li>Locally :inear Embedding</li><li>Laplacian Eigenmaps</li></ul></li><li><p><strong>推荐算法</strong>：推荐算法在我们的日常生活中比较常用，我们手机每天收到的各种推送、推荐消息全都采用了推荐算法。推荐算法的主要用途就是向用户推荐用户可能喜欢的东西，主要有以下几种：</p><ul><li>基于用户信息的推荐：根据用户的基本信息，推荐他们可能喜欢的东西。</li><li>基于物品信息的推荐：根据用户看过的物品，推荐与该物品相似的东西。</li><li>协同过滤推荐：找到和用户具有相似爱好的人，并断定这一群具有相似爱好的人喜欢的东西也相似，基于此推荐用户其他人看过但自己没看过的东西。</li><li>混合推荐：顾名思义，就是将以上几种算法混合起来。</li></ul></li><li><p><strong>其他算法</strong>：机器学习界算法很多，还有很多其他的算法，比如高斯判别、朴素贝叶斯、决策树等算法，这里不做介绍。</p></li></ol><p>介绍了这么多算法，我们来给它们分一下类：</p><ul><li>监督学习算法： 回归算法，神经网络，SVM</li><li>无监督学习算法：聚类算法、降维算法</li><li>特殊算法：推荐算法</li></ul><h2 id="机器学习的应用"><a href="#机器学习的应用" class="headerlink" title="机器学习的应用"></a>机器学习的应用</h2><ol><li><strong>数据挖掘</strong>：数据挖掘就是在大量数据中通过算法找到其中隐藏的信息，而说到数据挖掘，通常与机器学习离不开，因为数据挖掘的很多常用方法都来源于机器学习。</li><li><strong>深度学习</strong>：深度学习源于对人工神经网络的研究，具有多隐层的神经网络称为深度神经网络，对深度神经网络的研究称为深度学习，可以说，深度学习是机器学习的一个子类。</li><li><strong>人工智能</strong>：人工智能是让计算机模拟人的思维过程和智能行为，人工智能可以说是机器学习的父类，对人工智能的研究过程中机器学习才发展起来。</li></ol><p><strong>参考</strong></p><ul><li><a href="https://www.jianshu.com/p/ed9ae5385b89" target="_blank" rel="noopener">浅谈机器学习基础</a></li><li><a href="https://www.cnblogs.com/subconscious/p/4107357.html#four" target="_blank" rel="noopener">从机器学习谈起</a></li><li><a href="https://www.zhihu.com/question/41979241/answer/123545914" target="_blank" rel="noopener">什么是迁移学习</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/07/neural-network.html" target="_blank" rel="noopener">神经网络入门</a></li><li><a href="https://blog.csdn.net/abc200941410128/article/details/78541273?locationNum=1&amp;fps=1" target="_blank" rel="noopener">聚类算法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开拓视野 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Effective STL笔记</title>
      <link href="/effective_stl_note/"/>
      <url>/effective_stl_note/</url>
      
        <content type="html"><![CDATA[<h2 id="一-容器"><a href="#一-容器" class="headerlink" title="一.容器"></a>一.容器</h2><h3 id="第1条：慎重选择容器类型"><a href="#第1条：慎重选择容器类型" class="headerlink" title="第1条：慎重选择容器类型"></a>第1条：慎重选择容器类型</h3><p>C++提供了几种不同的容器供选择，他们之间各有差别，简单回顾一下：</p><ul><li>标准STL序列容器：vector、string、deque、list。</li><li>标准STL关联容器：set、multiset、map、multimap。</li><li>非标准序列容器：slist（单向链表）、rope（”重型”string）。</li><li>非标准关联容器：hash_set、hash_multiset、hash_map、hash_multimap（均基于哈希表）。</li><li>vector&lt;char>作为string的替代：第13条中讲述了何种条件下这种替代的意义。</li><li>vector作为标准关联容器的替代：第23条中阐述了，有时vector在运行时间和空间上都要优于标准关联容器。</li><li>几种标准的非STL容器：数组、bitset、valarray、stack、queue、priority_queue，第16条中提及了一种“数组优于STL容器”的情形；第18条中解释了bitset比vector&lt;bool>要好；另外，数组也可被用于STL算法，这是因为指针可被用作数组的迭代器。</li></ul><p>如上，可做出的选择是很多的，这意味着我们在做出选择的时候要考虑多种因素，C++标准对“如何在vector、deque和list中做出选择”提供的建议：</p><blockquote><p>vector、list和deque为程序员提供了不同的复杂性，使用时要对此做出权衡。vector是默认应使用的序列类型；当需要频繁地在序列中间做插入和删除操作时，应使用list；当大多数插入与删除操作发生在序列的头部和尾部时，deque是应考虑的数据结构。</p></blockquote><p>以上建议如果是从算法复杂性考虑的话，是恰当的，但除此之外应考虑的还有很多。</p><p>STL有一种分类方法，这是对连续内存容器和基于节点的容器的区分：</p><ul><li>连续内存容器：把它的元素存放在一块或多块（动态分配的）内存中，每块内存中存有多个元素，当有新元素插入或已有元素被删除时，同一内存块中的其他元素要向前或向后移动，为新元素让出空间，或者填充被删除的元素。这种移动影响到效率（参见第5条，第14条）和异常安全性。标准的连续内存容器有vector、string和deque，非标准的rope也是一个连续内存容器。</li><li>基于节点的容器：每一个（动态分配的）内存块中只存放一个元素。容器元素的插入或删除值只影响到指向节点的指针，而不影响节点本身的内容，所以当有插入或删除操作时，元素值不需要移动。表示链表的容器，如list和slist，是基于节点的；所有标准的关联容器也是如此（通常实现方式为平衡树）；非标准的哈希容器使用不同的基于节点的实现，第25条可看到这一点。</li></ul><p>有了以上术语基础，以下是选择容器时应考虑的一些问题：</p><a id="more"></a><ul><li><strong>是否需要在容器的任意位置插入新元素？</strong> 需要就选序列容器，关联容器不可行。</li><li><strong>是否关心容器内元素是否排序？</strong> 不关心可考虑哈希容器，否则避免哈希容器。</li><li><strong>选择的容器必须是标准C++的一部分吗？</strong> 如果是，请选择标准容器。</li><li><strong>你需要哪种类型的迭代器？</strong> 如果要求随机访问迭代器，请选择vector、deque、string之一。</li><li><strong>发生元素的插入或删除时，是否关心容器内的元素是否移动？</strong> 连续内存容器通常会移动容器内元素。</li><li><strong>容器内数据布局是否需要与C兼容？</strong> 如果需要兼容，只能选择vector（第16条）。</li><li><strong>是否在意元素查找速度？</strong> 如果是，依次考虑哈希容器（第25条）、排序的vector（第23条）、标准关联容器。</li><li><strong>是否介意容器内部使用了引用计数技术？</strong> 如果是，避免string，许多string的实现都使用了引用计数技术。如果你需要某种表示字符串的方法，可考虑vector&lt;char>。</li><li><strong>对插入与删除操作，你需要回滚能力吗？</strong> 如果需要，请使用基于节点的容器。如果对多个元素的插入操作（即针对一个区间的形式，见第5条）需要回滚能力，请选择list，list提供了这种功能。对于希望编写异常安全代码的人，回滚能力是很重要的（使用连续内存的容器也可以获得这种能力，不过要付出性能上的代价，而且代码也显得不那么直截了当，更多细节请参考Sutter的Exceptional C++中的第17条）。</li><li><strong>你需要使迭代器、指针和引用变为无效的次数最少吗？</strong> 如果是，请使用基于节点的容器，这类容器的插入与删除从来不会使迭代器、指针、引用失效（除非你指向一个你正在删除的元素），而对于连续内存容器，插入和删除操作一般会使迭代器、指针、引用失效。</li><li><strong>你介意在容器上使用swap，使得迭代器、指针和引用失效吗？</strong> 如果介意，避免string，string是STL中唯一在swap过程中使得迭代器、指针和引用失效的容器。</li></ul><p>以上并没有涵盖所有的情形，但你应该明白，在选择容器时，有很多要素要考虑，有在任何情况下都应该默认选择的容器吗？并没有。</p><h3 id="第2条：不要试图编写独立于容器类型的代码"><a href="#第2条：不要试图编写独立于容器类型的代码" class="headerlink" title="第2条：不要试图编写独立于容器类型的代码"></a>第2条：不要试图编写独立于容器类型的代码</h3><p>STL是以泛化原则为基础的：数组被泛化为“以其包含的对象类型为参数”的容器，函数被泛化为“以其使用的迭代器类型为参数”的算法，指针被泛化为“以其指向的对象为类型”的迭代器。</p><p>你看这泛化的不断进行，不禁也想进行一些泛化，比如对自己软件中所使用的容器进行泛化，想把容器的概念泛化：现在程序代码使用的是vector，以后改换成deque或list但并不用改变使用容器的代码。这类泛化，几乎总是错误的。</p><p>试图编写对于序列容器和关联容器都适用的代码几乎毫无意义，因为很多成员函数是对某一特定容器才存在的，而你若想编写通用代码，只能使用容器功能的交集，而至于这个交集是什么，种种限制与考虑过后，你的“泛化容器”将不能使用大部分操作，而剩余的操作也将耗费你不期望的时间，这不会是你想要的容器。</p><p>面对现实吧，不同容器就是不同的，他们有非常明显的优缺点，他们并不是被设计来交换使用的，而你又想稳，有一天我发现我曾经选择的容器不是最佳的容器，我该怎么办呢？</p><p>考虑有时候不可避免的要从某种容器类型转到另一种，一种常规的方式便是使用封装技术：</p><p>最简单的方式，使用typedef（c++11可使用using），所以，不要这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Widget&gt; vw;</span><br><span class="line">Widget bestWidget;</span><br><span class="line">...               <span class="comment">//对bestWidget赋值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Widget&gt;::iterator i =              <span class="comment">//找到一个与bestWidget</span></span><br><span class="line">    find(vw.begin(), vw.end(), bestWidget)<span class="comment">//具有相同值的Widget</span></span><br></pre></td></tr></table></figure><p>而应该这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Widget&gt; Widget_container;<span class="comment">//使用类型别名</span></span><br><span class="line">Widget_container vw;</span><br><span class="line">Widget bestWidget;</span><br><span class="line">...               <span class="comment">//对bestWidget赋值</span></span><br><span class="line">Widget_container::iterator i =</span><br><span class="line">    find(vw.begin(), vw.end(), bestWidget)</span><br></pre></td></tr></table></figure><p>不过，类型定义只是其他类型的别名，它带来的封装只是词法上的，无法阻挡客户做一些他们原本不能做到的事情，如果你不想把自己使用的容器暴露给客户，可以把容器隐藏到一个类里，尽量减少那些通过类接口（而使外部）可见的、与容器相关的信息。这样当你想改变使用的容器时，只需重写类相关成员函数的实现即可，客户代码则几乎不用变动。</p><h3 id="第3条：确保容器中的对象拷贝正确而高效"><a href="#第3条：确保容器中的对象拷贝正确而高效" class="headerlink" title="第3条：确保容器中的对象拷贝正确而高效"></a>第3条：确保容器中的对象拷贝正确而高效</h3><p>容器中保存了对象，但并不是你提供给容器的那些对象，当向容器中添加对象时，存入容器的是你所指定的对象的拷贝（以下均不考虑C++11中的新特性“移动”）。而当对象被保存到容器中后，它经常会被进一步拷贝，比如：向vector、string、deque中插入或删除元素，现有元素的位置通常会被移动（复制），而使用排序算法、next_permutation或pre_permutation、remove、unique或类似操作、rotate或reverse等等算法，对象会被移动（拷贝），拷贝对象是STL的工作方式，而拷贝对象的方式则很简单，通常是利用一个对象的拷贝成员函数。</p><p>本条款的意图，是让你意识到，如果你向容器中填充对象，而对象的拷贝操作又很费时，那么这一简单的操作将会成为程序的性能瓶颈，而放入容器的对象越多，拷贝所需要的时间和空间就越多，而且，如果这些“拷贝”有特殊的含义，程序还将不可避免地出错。（其中一种情形参见第8条）。</p><p>另外，如果存在继承关系，拷贝动作将会导致剥离，也就是说，如果你创建一个保存基类对象的容器，却向其中插入派生类的对象，那么派生类对象在被拷贝进容器时，他所特有的非基类部分的信息将会丢失，这样做几乎总是错误的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Widget&gt; vw;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWidget</span>:</span>    <span class="comment">//SpecialWidget继承自Widget</span></span><br><span class="line">    <span class="keyword">public</span> Widget&#123;...&#125;;</span><br><span class="line">SpecialWidget sw;</span><br><span class="line">vw.push_back(sw);       <span class="comment">//sw作为基类对象被拷贝进vw中</span></span><br><span class="line">                        <span class="comment">//它所特有的派生类部分在拷贝时被丢掉了</span></span><br></pre></td></tr></table></figure><p>使拷贝动作高效，正确，并且防止剥离的一种简单方法是使容器包含指针而不是对象本身，不过，指针本身也有一些令人头疼的、与STL相关的问题，参考第7条和第33条。而要想避免刚才的问题，智能指针是一个诱人的选择，不过，智能指针也存在一些问题（参考第8条）。</p><p>以上的讲述，可能会让人觉得STL是在疯狂地拷贝，那让我们最后来想一想这个问题：没错，STL是做了很多拷贝，但它的总设计思想是为了避免不必要的拷贝，而事实上，它的设计目的是为了避免创建不必要的对象，把它和数组做一下比较：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Widget w[maxNumWidgets];<span class="comment">//创建了有maxNumWidgets个Widget的数组</span></span><br><span class="line">                        <span class="comment">//每个对象都使用默认构造函数创建</span></span><br></pre></td></tr></table></figure><p>这将创建maxNumWidgets个Widget对象，无论你是否使用它们；而使用vector，则容器则会在它需要时才会增长，与内置数组相比，STL容器要聪明得多，STL是在创建拷贝，不过，比起数组而言，它还是迈出了一大步的。</p><h3 id="第4条：调用empty-而不是检查size-是否为0"><a href="#第4条：调用empty-而不是检查size-是否为0" class="headerlink" title="第4条：调用empty()而不是检查size()是否为0"></a>第4条：调用empty()而不是检查size()是否为0</h3><p>对任意容器而言，下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(c.size() == <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>语义上与</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(c.empty());</span><br></pre></td></tr></table></figure><p>是等价的，不过，这两种形式是有差别的，差别是：empty对所有的标准容器都是常数时间，而对一些list实现，size耗费线性时间。为什么？</p><p> 原因在于list所独有的链接（splice）操作，当对list进行链接后，原list中的元素数目是它链接前元素数目加上链接过来的元素数目，但如何知道链接过来的元素究竟有多少个呢？你可能会想，既然用户想知道list中有多少元素，你想设计list，使size花费常数时间，但同时，你知道在所有的标准容器中，只有list具有把元素从一处链接到另一处而不需要拷贝任何数据的能力，很多人选择list的原因就是它提供了高效的链接操作，他们希望从一个区间从一个list链接到另一个list花费常数时间，这样，你想满足他们，使splice操作花费常数时间。</p><p> 那么，问题来了，如果size花费常数时间，那么每个list成员函数操作就必须更新它们操作的链表的大小，当然包括splice，这样，splice就必须遍历区间，不再花费常数时间，而如果你想让splice花费常数时间，size就必须花费线性时间计算大小，他们两个，只有一个可以成为常数时间操作。</p><p> 不同的list实现通过不同的方式解决上述冲突，这取决于作者。而调用empty()，总会花费常数时间。</p><h3 id="第5条：区间成员函数优先于与之对应的单元素成员函数"><a href="#第5条：区间成员函数优先于与之对应的单元素成员函数" class="headerlink" title="第5条：区间成员函数优先于与之对应的单元素成员函数"></a>第5条：区间成员函数优先于与之对应的单元素成员函数</h3><p>优先选择区间成员函数而不是其对应的单元素成员函数有三条充分的理由：</p><ul><li>区间成员函数写起来更容易</li><li>更容易表达你的意图，可读性更好</li><li>效率更高，这表现在很多方面</li></ul><p>首先，写下列代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1.assign(v2.begin() + v2.size() / <span class="number">2</span>, v2.end());</span><br></pre></td></tr></table></figure><p>肯定比写下列代码可读性要好：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v1.clear();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;Widget&gt;::cnst_iterator ci = v2.begin() + v2.size() / <span class="number">2</span>;</span><br><span class="line">    ci != v2.end(); ++ci)</span><br><span class="line">    v1.push_back(*ci);</span><br></pre></td></tr></table></figure><p>另外，第一种方式仅调用了一次assign，而第二种方式调用了（v2.size() / 2）次push_back, 也许assign内部也是和第二种方式类似，也许它直接把这一大块数据进行赋值，不管怎样，在这里区间成员函数总比单元素成员函数要好。</p><p>而且，从内存分配方面考虑，考虑到向vector中添加元素时，如果vector内存已满，那么vector通常会扩充他的容量（假设是加倍），那么，第二种方式，vector每次都只添加一个元素，vector并不知道自己最后总共要添加多少个元素，vector应该会进行log（v2.size() / 2）次容量扩充，而第一种方式，vector在添加元素前便已经知道自己需要多少元素，因此不必多次扩充容量，这一节省的时间是很可观的。</p><p>不只是对vector，对于string，deque，list使用区间成员函数也可以避免不必要的时间开销，从而获得高效率。</p><h3 id="第6条：当心C-编译器最烦人的分析机制"><a href="#第6条：当心C-编译器最烦人的分析机制" class="headerlink" title="第6条：当心C++编译器最烦人的分析机制"></a>第6条：当心C++编译器最烦人的分析机制</h3><p>假设你有一个存有int的文件，你想把这些int复制到一个list中，下面是很“合理”的一种做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">data_file</span><span class="params">(<span class="string">"ints.dat"</span>)</span></span>;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; data(istream_iterator&lt;<span class="keyword">int</span>&gt;(data_file),</span><br><span class="line">               istream_iterator&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure><p>这段代码可以通过编译，但是在运行时，它什么也不会做，为什么？</p><p>先从最基本的说起，现在，声明一个带double参数返回int的函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> d)</span></span>;</span><br></pre></td></tr></table></figure></p><p>下面代码做了同样的事，d两边的括号是多余的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int f(double (d)); //d两边的括号会被忽略</span><br></pre></td></tr></table></figure></p><p>下面代码也做了同样的事，只是省略了参数名称：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>)</span></span>;     <span class="comment">//参数名称被忽略</span></span><br></pre></td></tr></table></figure></p><p>以上三种形式的声明你应该很熟悉，再来看三个声明：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int g(double (*pf)());  //g的参数是一个函数（无参数，返回double）指针</span><br></pre></td></tr></table></figure></p><p>这样写和上面的意思一致：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int g(double pf());     //pf为隐式指针</span><br></pre></td></tr></table></figure></p><p>同样，你也可以省略参数名称：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int g(double ());     //省略参数名称</span><br></pre></td></tr></table></figure></p><p>注意围绕参数名的括号和独立括号的区别，围绕参数名的括号被忽略，独立括号意味着参数列表的存在：存在一个函数指针参数。</p><p>现在我们来看开始的问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">data_file</span><span class="params">(<span class="string">"ints.dat"</span>)</span></span>;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; data(istream_iterator&lt;<span class="keyword">int</span>&gt;(data_file),</span><br><span class="line">               istream_iterator&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure><p>这里<strong>声明</strong>了一个函数，data，它的返回值是list&lt;int>，这个data函数有两个参数：</p><ul><li>第一个参数名称为data_file，它的类型为istream_iterator&lt;int>，data_file两边的括号是多余的，被忽略。</li><li>第二个参数没有名称，它的类型是一个函数指针，指向一个没有参数，返回istream_iterator&lt;int>的函数。</li></ul><p>这很令人吃惊！但它与C++中的一条规律相符，即尽可能的解释为函数声明，举个例子，如果你写C++有一段时间了，你肯定遇到过下面错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span>...&#125;;<span class="comment">//假设Widget有默认构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w</span><span class="params">()</span></span>;       <span class="comment">//想显式调用默认构造函数？</span></span><br></pre></td></tr></table></figure><p>这可没有声明一个名为w的Widget，而是声明了一个名为w的函数。</p><p>通过增加一对括号，强迫编译器按照我们想要的方式工作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">data_file</span><span class="params">(<span class="string">"ints.dat"</span>)</span></span>;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; data((istream_iterator&lt;<span class="keyword">int</span>&gt;(data_file)),</span><br><span class="line">               istream_iterator&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure></p><p>这是声明data的正确方式，此外，还有一种办法，那就是避免在data声明中使用匿名的istream_iterator对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">data_file</span><span class="params">(<span class="string">"ints.dat"</span>)</span></span>;</span><br><span class="line"><span class="function">istream_iterator <span class="title">data_begin</span><span class="params">(data_file)</span></span>;</span><br><span class="line">istream_iterator data_end;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; data(data_begin,data_end);</span><br></pre></td></tr></table></figure></p><p>虽然使用命名的迭代器对象与通常的STL风格相违背，不过以上方式可避免使代码有二义性，并且使维护代码的人理解起来更容易。</p><h3 id="第7条：如果容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉"><a href="#第7条：如果容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉" class="headerlink" title="第7条：如果容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉"></a>第7条：如果容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉</h3><p>STL中的容器，会自己进行适当的内存管理，当他们被析构时，他们会自动析构所包含的每个对象，不要以为这样你就无需考虑清理问题，如果容器包含的是通过new方式而分配的指针，容器的确会析构掉它包含的每个指针，但并不会调用delete，这会导致内存泄漏。</p><p>你可以选择在容器还没析构时，自己手动调用delete来解决这个问题，但这并不是异常安全的。假如你在删除指针过程中抛出了异常，剩下的指针就不会被delete，同样会发生资源泄漏，怎么办呢？最简单的方法就是使用智能指针，不过，千万不要使用auto_ptr！（参见第8条），此外，你也可以选择使用RAII（智能指针实际上就是RAII的一个例子）。</p><h3 id="第8条：切勿创建包含auto-ptr的容器对象"><a href="#第8条：切勿创建包含auto-ptr的容器对象" class="headerlink" title="第8条：切勿创建包含auto_ptr的容器对象"></a>第8条：切勿创建包含auto_ptr的容器对象</h3><p>首先明确一点，auto_ptr的容器是被禁止的，按照标准，试图违反这一条规定的代码不会通过编译。那么，为什么呢？</p><p>回顾一下之前所说的，容器会做很多拷贝操作，拷贝auto_ptr意味着什么？当你拷贝一个auto_ptr时，它所指的对象的所有权会被移交给复制的auto_ptr上，而它自身被置为NULL：拷贝一个auto_ptr意味着改变它的值！</p><p>这一现象会导致程序出现各种各样奇怪的问题，比如说：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; &gt; v;   <span class="comment">//这不应该通过编译</span></span><br><span class="line">...</span><br><span class="line">sort(v.begin(), v.end(),    <span class="comment">//对vector排序</span></span><br><span class="line">[](<span class="keyword">const</span> <span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt;&amp; l, <span class="keyword">const</span> <span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt;&amp; r)&#123; <span class="keyword">return</span> *l &gt; *r ;&#125;);<span class="comment">//lambda</span></span><br></pre></td></tr></table></figure><p>这段代码看起来没什么问题，但实际上呢？在排序的过程中，v中的一个或者多个auto_ptr可能会被置为NULL，对v的排序竟然改变了v的内容！</p><p>如果你想使用包含智能指针的容器，别害怕，这是没有问题的，有问题的是auto_ptr不是应该放在容器中使用的智能指针。</p><h3 id="第9条：慎重选择删除元素的方法"><a href="#第9条：慎重选择删除元素的方法" class="headerlink" title="第9条：慎重选择删除元素的方法"></a>第9条：慎重选择删除元素的方法</h3><p>假定你有一个下面的容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Container&lt;<span class="keyword">int</span>&gt; c;</span><br></pre></td></tr></table></figure><p>如果你想删除c中所有值为2017的元素，完成这一任务的方式是随着容器类型而异的：</p><ul><li><p>如果容器是连续内存容器（vector、deque、string），最好的办法是采用erase-remove习惯用法（见第32条）：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.erase(remove(c.begin(), c.end(), <span class="number">2017</span>), c.end());</span><br></pre></td></tr></table></figure></li><li><p>如果是list，erase-remove方法同样有效，不过推荐使用成员函数remove：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.remove(<span class="number">2017</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果容器是标准关联容器（set、multimap，map，multimap），对这些容器使用remove算法，可能会覆盖容器的值并破坏容器（见第22条），而这类容器根本没有remove成员函数，所以请调用erase成员函数：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.erase(<span class="number">2017</span>);</span><br></pre></td></tr></table></figure></li></ul><p>现在改变一下需求，我们要删除c中满足下面判别式的每一个对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">q</span><span class="params">(<span class="keyword">int</span> )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>对于序列容器（vector，string，deque，list），把remove调用换成remove_if就可以了：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.erase(remove_if(c.begin(), c.end(), q),<span class="comment">//当c是vector、string、</span></span><br><span class="line">        c.end());                        <span class="comment">//deque时，这是最佳办法</span></span><br><span class="line"></span><br><span class="line">c.remove_if(q);                          <span class="comment">//当c是list的最佳办法</span></span><br></pre></td></tr></table></figure></li><li><p>对于关联容器，有两种办法，一种利于编码，另一种效率更高：</p><ul><li><p>易于编码的方法，利用remove_copy_if把我们需要的值复制到另一个新容器中，再把原来容器中的内容与新容器中的内容交换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AssocContainer&lt;<span class="keyword">int</span>&gt; c;      <span class="comment">//c是一个关联容器</span></span><br><span class="line">...</span><br><span class="line">AssocContainer&lt;<span class="keyword">int</span>&gt; good_c; <span class="comment">//存放需要的值</span></span><br><span class="line">remove_copy_if(c.begin(), c.end(),</span><br><span class="line">                inserter(good_c, good_c.end()),</span><br><span class="line">               q);</span><br><span class="line">c.swap(good_c);</span><br></pre></td></tr></table></figure></li><li><p>效率更高的方法，写一个循环遍历并删除要删除的元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AssocContainer&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(AssocContainer&lt;<span class="keyword">int</span>&gt;::iterator i = c.begin();</span><br><span class="line">    i != c.end(); ++i)</span><br><span class="line">    <span class="comment">//注意，下面这里必须要写i++，因为当关联容器中的一个元素</span></span><br><span class="line">    <span class="comment">//被删除时，指向该元素的所有迭代器都会失效，必须先递增</span></span><br><span class="line">    <span class="comment">//迭代器，再返回指向该删除的那个元素的迭代器</span></span><br><span class="line">    <span class="keyword">if</span>(q(*i))   c.erase(i++);</span><br><span class="line">    <span class="keyword">else</span>        ++i;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>现在再改一下需求，我们在上面的基础上，希望每次元素删除时，都能向一个日志文件中写一条信息：</p><ul><li><p>对于关联容器，这十分简单，只需要对循环简单修改：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ofstream logfile;</span><br><span class="line">AssocContainer&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(AssocContainer&lt;<span class="keyword">int</span>&gt;::iterator i = c.begin();</span><br><span class="line">    i != c.end(); ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(q(*i))&#123;</span><br><span class="line">        logfile &lt;&lt; <span class="string">"Erase"</span> &lt;&lt; *i &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//写日志文件</span></span><br><span class="line">        c.erase(i++);                     <span class="comment">//删除元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>        ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于vector、string、deque，我们无法使用erase-remove方法了，这个方法无法写日志文件。而且我们不能用和关联容器一样的方法，因为调用erase后，指向被删除元素自身以及它之后所有元素的迭代器都会失效！我们要利用erase函数的返回值，它会返回紧跟被删除元素的下一个元素的有效迭代器：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(SeqContainer&lt;<span class="keyword">int</span>&gt;::iterator i = c.begin();</span><br><span class="line">    i != c.end(); ++i)</span><br><span class="line">    <span class="keyword">if</span>(q(*i))&#123;</span><br><span class="line">        logfile &lt;&lt; <span class="string">"Erase"</span> &lt;&lt; *i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        i = c.erase(i);       <span class="comment">//把erase返回值赋给i，使i的值有效</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>        ++i;</span><br></pre></td></tr></table></figure></li><li><p>对于list，就遍历和删除来说，你可以把它当作vector/string/deque对待，也可以把它当作关联容器对待，两种方式对list都适用，通常是把list看作vector/string/deque对待。</p></li></ul><p>总结一下：</p><ul><li>要删除容器中有特定值的所有对象：<ul><li>如果容器是vecotr/string/deque，则使用erase-remove方法。</li><li>如果容器是list，使用list::remove。</li><li>如果容器是标准关联容器，使用它的而erase成员函数。</li></ul></li><li>要删除容器中满足特定判别式的所有对象：<ul><li>如果容器是vecotr/string/deque，则使用erase-remove_if方法。</li><li>如果容器是list，使用list::remove_if。</li><li>如果容器是标准关联容器，使用remove_copy_if和swap，或者写一个循环遍历容器中的元素，注意把迭代器传给erase时，对它进行后缀递增。</li></ul></li><li>要在循环内部做某些（除了删除对象之外）操作：<ul><li>如果容器是标准序列容器，写一个循环遍历元素，注意每次调用erase时，用它的返回值更新迭代器。</li><li>如果容器是标准关联容器，写一个循环遍历元素，注意把迭代器传给erase时，对它进行后缀递增。</li></ul></li></ul><h3 id="第10条：了解分配子（allocator）的约定和限制"><a href="#第10条：了解分配子（allocator）的约定和限制" class="headerlink" title="第10条：了解分配子（allocator）的约定和限制"></a>第10条：了解分配子（allocator）的约定和限制</h3><p>分配子很奇怪，它的最初设计意图是提供一个内存模型的抽象，像new操作符和new[]操作符一样，STL内存非配置负责分配（释放）原始内存，但它提供的接口和new操作符，new[]操作符甚至malloc一点也不相似，而且，很多标准容器从来不向与之关联的分配子申请内存，从来没有，这使分配子变得很怪异。</p><p>C++标准中，一个类型为T的对象，它的默认分配子（allocator&lt;T>）提供了两个类型定义，allocator&lt;T>::pointer, allocator&lt;T>::reference，用户定义的分配子也应该提供这些类型定义。</p><p>这里有些问题，对吗？C++中，引用是不可能仿冒的，因为这需要重载operator.（点操作符），可这个操作符是不允许重载的，并且，创建这种具有引用特点的对象是使用代理对象的一个例子，而使用代理对象会有很多问题（详见More Effective C++ 第30条）。</p><p>C++标准明确指出，允许库实现者假定每个分配子的指针类型等同于T*，而引用类型等同于T&amp;，也就是说，库实现者可以忽略类型定义，直接使用指针和引用。</p><p>这很怪异，对吧？再来一个，分配子是对象，意味着它可以有成员函数，嵌套类型和类型定义，而C++标准说，STL的实现可以假定所有属于同一类型的分配子对象都是等价的，并且相互比较的结果总是相等的，很糟糕？这还是有理由的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialAllocator</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="keyword">typedef</span> SpecialAllocator&lt;Widget&gt; SAW;</span><br><span class="line"><span class="built_in">list</span>&lt;Widget,SAW&gt; list1;</span><br><span class="line"><span class="built_in">list</span>&lt;Widget,SAW&gt; list2;</span><br><span class="line">...</span><br><span class="line">list1.splice(list1.begin(),list2);<span class="comment">//把list2的节点移动到list1的前面</span></span><br></pre></td></tr></table></figure><p>想一下，当list中的元素被链接到另一个时，没有复制任何东西，只有一些指针值被调整，那么，当list1被析构时，它必须释放自己所有的节点（包括从list2链接过来的节点），因为假定同一类型的分配子是等价的，所以由list2分配子对象分配的内存就可以由list1分配子对象安全的释放。</p><p>但是再想一想，假定同一类型的分配子是等价的其实是一个很严苛的限制，它意味着可移植的（在不同的STL实现下都可以正确工作）分配子不可以有状态，也就是任何<strong>非静态的成员</strong>，至少不能有影响其行为的数据成员，因为这样，两个分配子对象就有可能不再等价了。</p><p>再来讨论下分配子分配原始内存这点，它的接口与new操作符是不同的，看看他们的声明，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> butes)</span></span>;</span><br><span class="line"><span class="comment">//pointer是个类型定义，它实际上总是T*</span></span><br><span class="line">pointer allocator&lt;T&gt;::allocate(size_type numObjects);</span><br></pre></td></tr></table></figure><p>两者都带参数指定要分配多少内存，对于operator new，指明的是一定数量的字节，而对于allocate，指明的是内存中要容纳多少个T对象。</p><p>它们的返回值也不同，operator new返回void*，指向未初始化内存，而allocator&lt;T>::allocate返回T*，可是，此时T尚未构造！STL有着这样的期望：allocator&lt;T>::allocate的调用者最终会在返回的内存中构造一个或者多个T对象（可能通过allocator&lt;T>::construct，或者通过uninitialized_fill，或者通过raw_storage_iterator的某些应用），但是在vector::reserve，string::reserve的情况下，这种构造可能根本没有发生过（见第14条）。</p><p>这样，来看一下分配子最后一个奇怪的地方，即大多数标准容器从来没有单独调用过对应的分配子，举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line"><span class="built_in">set</span>&lt;Widget, SAW&gt; s;</span><br></pre></td></tr></table></figure><p>这一现象对于list和所有的标准关联容器都存在（set、multiset、map、multimap），这是因为它们是基于节点的容器，也就是说每当新节点插入容器中时，节点是被动态分配的。</p><p>考虑一下list&lt;T>的一个可能实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">         <span class="keyword">typename</span> Allocator = allocator&lt;T&gt; &gt;</span><br><span class="line">class <span class="built_in">list</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Allocator alloc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span>&#123;</span></span><br><span class="line">        T data;</span><br><span class="line">        Listnode *pre;</span><br><span class="line">        Listnode *next;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当新的元素被插入到容器时，我们需要通过分配子获得内存，但我们并不需要T的内存，我们需要的是Listnode的内存，这让我们的Allocator对象毫无用处。不过，分配子按照约定解决了这个问题，它定义了一个类型other，这个类型能从已有的分配子类型向与Listnode类型相适应的分配子过渡，可能说的有点绕，直接看它的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allocator</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebind</span>&#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> allocator&lt;U&gt; other;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>像上面这么写过的话，Listnode的分配子的类型为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Allocator::rebind&lt;Listnode&gt;::other</span><br></pre></td></tr></table></figure></p><p>如果你想自己自己写一个自定义的分配子，并想让它同标准容器一起工作，那么你的分配子必须提供rebind模版。</p><p>总结一下：</p><ul><li>你的分配子是一个模版，模版参数T代表你为它分配内存的对象的类型。</li><li>提供类型定义pointer和reference，并始终让pointer为T*，reference为T&amp;。</li><li>不要让你的分配子拥有随对象不同的状态，通常分配子不应该有非静态的数据成员。</li><li>传给分配子的allocate成员函数的是你要求内存的对象的个数，并且函数返回T*指针，即使尚未有T对象被构造出来。</li><li>一定要提供嵌套的rebind模版。</li></ul><h3 id="第11条：理解自定义分配子的合理用法"><a href="#第11条：理解自定义分配子的合理用法" class="headerlink" title="第11条：理解自定义分配子的合理用法"></a>第11条：理解自定义分配子的合理用法</h3><p>有时，你觉得STL默认的allocator太慢，或者浪费内存，想写自己的分配子，自定义的分配子可以把STL容器放在你建立的共享内存中，或者放在一个特殊堆中的相邻位置，自定义分配子在很多场合下都很有用，只要你遵守分配子的种种限制。</p><h3 id="第12条：切勿对STL容器的线程安全性有不切实际的依赖"><a href="#第12条：切勿对STL容器的线程安全性有不切实际的依赖" class="headerlink" title="第12条：切勿对STL容器的线程安全性有不切实际的依赖"></a>第12条：切勿对STL容器的线程安全性有不切实际的依赖</h3><p>在线程方面，你对STL的实现只能期望：</p><ul><li>多个线程读是安全的。</li><li>多个线程对不同的容器做写入操作是安全的。</li></ul><p>写多线程的代码是不容易的，你可能希望STL实现能提供完全的线程安全性，但，这很困难，考虑一下实现一个库实现线程安全性可能采用的方式：</p><ul><li>对容器成员函数的每次调用，都锁住容器直到调用结束。</li><li>在容器所返回的每个迭代器的生存期结束前，都锁住容器。</li><li>对于作用于容器的每个算法，都锁住该容器，直到算法结束。</li></ul><p>STL要想实现以上的要求，并根据你的代码自动提供线程安全性，并且不对程序造成显著的效率影响，非常非常难，你应该手动控制线程安全，比如采用RAII（resource acquisition is initialization）。</p><h2 id="二-vector和string"><a href="#二-vector和string" class="headerlink" title="二.vector和string"></a>二.vector和string</h2><h3 id="第13条：vector和string优先于动态分配的数组"><a href="#第13条：vector和string优先于动态分配的数组" class="headerlink" title="第13条：vector和string优先于动态分配的数组"></a>第13条：vector和string优先于动态分配的数组</h3><p>如果你决定用new动态分配内存，意味着：</p><ul><li>你必须确保之后的代码中用delete删除所分配的内存。</li><li>你必须确保使用了正群的delete形式，delete或delete[]。</li><li>你必须确保只delete了一次。</li></ul><p>忘记了以上任何一条就很有可能导致你的程序无法正常工作或发生内存泄漏，但使用vector和string，你便不用考虑这些事情。</p><p>同时，vector和string是标准的STL序列容器，它们有很多操作，也可以应用适合于序列容器的STL算法（虽然数组也可以，但毕竟数组自己无法提供begin()，end()等操作），如果你想支持老版本的代码，vector和string也可以很方便的把数据传给旧的API。</p><p>另外，某些string实现在背后采用了引用计数技术，这种技术可以消除不必要的内存分配和不必要的字符拷贝，可以提高应用程序的效率，不过，在多线程环境下使用采用引用计数的sting时，你在背后同步控制的时间可能比引用计数节省的时间还多，即引用计数技术反而影响了你的效率。这种情况下，你可以：</p><ul><li>检查库实现，看是否可以禁止引用计数。</li><li>换用另一个没采用引用计数的string。</li><li>用vector&lt;char>代替string。</li></ul><h3 id="第14条：使用reserve来避免不必要的重新分配"><a href="#第14条：使用reserve来避免不必要的重新分配" class="headerlink" title="第14条：使用reserve来避免不必要的重新分配"></a>第14条：使用reserve来避免不必要的重新分配</h3><p>STL容器很好的一点是，它会自动增长以便容纳下你放入其中的数据，只要没超过它的最大限制（调用max_size()获取最大限制），对于vector和string，每当需要增长时，它调用和realloc类似的操作：</p><ol><li>分配一块大小为当前容量某个倍数的新内存，通常为2倍（？）。</li><li>把容器中所有元素从旧内存复制到新内存中。</li><li>析构旧内存中的对象。</li><li>释放旧内存。</li></ol><p>考虑上述过程，我们可以知道，整个过程会很耗时，并且，每当上述过程发生，vector和string的所有指针、迭代器和引用都会失效，呀，这可不好。</p><p>reserve成员函数可以让你把重新分配内存的次数减少到最低限度，从而减小了开销，解释该怎么使用reserve前，回忆一下容易混淆的函数，注意只有vector和string提供了下面全部四个函数：</p><ul><li>size()：容器中现在有多少个元素。</li><li>capacity()；容器利用当前已分配的内存可以容纳多少元素，注意，这是容器能容纳的元素总数，不是它还能容纳多少元素，如果想得知剩余空间，请用capacity()-size()。</li><li>resize(Container::size_type n)：强迫容器改变到包含n个元素的状态，即调用resize(n)后，size()返回n。如果n比size()小，则析构容器尾部的元素；如果n比size()大，则通过默认构造函数将创建的新元素添加到容器的末尾；如果n比capacity()大，则在添加元素前先重新分配内存。</li><li>reserve(Container::size_type n)：强迫容器把它的容量变为至少为n（n应不小于当前容量），通常，这会导致重新分配，因为容量会增加。如果n比容量小，vector会什么也不做，string可能会把自己的容量减为size()和n中的最大值，但是string的大小肯定不变，如果你想利用这个特性用reserve除去string多余的容量，不如使用“swap技巧”（见第17条）。</li></ul><p>只有当容器容量不够时，才会重新分配，为了避免重新分配，你有两种方式：</p><ol><li>如果确切知道或大致预计容器最终会有多少元素，在开始就用reserve预留适当大小的空间即可。</li><li>先预留足够大的空间，然后把所有数据加入后，再去除多余的容量，去除多余部分并不困难（见第17条）。</li></ol><h3 id="第15条：注意string实现的多样性"><a href="#第15条：注意string实现的多样性" class="headerlink" title="第15条：注意string实现的多样性"></a>第15条：注意string实现的多样性</h3><p>实现string的方式很多，string对象的大小也未必相同，不过，几乎每个string实现都包含如下信息：</p><ul><li>字符串的大小(size)，即它所包含的字符的个数。</li><li>用于存储该字符串中字符内存的容量。</li><li>字符串的值，即构成该字符串的字符。</li></ul><p>一个string可能包含：</p><ul><li>它的分配子的一份拷贝。</li></ul><p>建立在引用计数基础上的string实现可能包含：</p><ul><li>对值的引用计数。</li></ul><p>不同的string用不同方式组织上述信息，举4个例子：</p><p>A. 每个string对象包含其分配子的一个拷贝、该字符串的大小、它的容量、一个指向一块动态分配内存的指针，这块内存中包含了引用计数和字符串值。使用默认分配子的string对象大小是一个指针的4倍，使用自定义分配子则取决于自定义分配子的大小：</p><p><img src="/effective_stl_note/effective-stl-note/A.png" alt=""></p><p>B. 每个string对象包含一个指向一个结构的指针，由于用了优化，使用默认分配子不需要多余空间。结构中包含字符串的大小，容量和引用计数，一个指向动态分配内存（存放着字符串的值）的指针，还有一些与多线程环境下同步控制相关的额外数据（Other）。每个string对象的大小与指针大小相同：</p><p><img src="/effective_stl_note/effective-stl-note/B.png" alt=""></p><p>C. 每个string对象中包含一个指针，这个指针指向一块包含所有与字符串相关的数据（大小，容量，引用计数，值）的动态内存。没有对单个对象的分配子支持，还包含了一些与值的可共享性有关的数据（X），每个string对象的大小总与指针相同：</p><p><img src="/effective_stl_note/effective-stl-note/C.png" alt=""></p><p>D. 每个string对象中包含一块内存，最多可容纳15个字符的字符串，而当string的容量超过15时，该内存的起始部分被当作一个指向动态分配内存的指针，这称为“小字符串优化”，该实现不使用引用计数。每个string对象的大小是指针的7倍：</p><p><img src="/effective_stl_note/effective-stl-note/D.png" alt=""></p><p>通过上面的4个例子，你应该考虑在不同情况下应选择哪种string实现，不同的实现有很多区别，总结：</p><ul><li>string的值是否被引用计数。</li><li>string对象大小的范围可以为一个char*指针大小的1~7倍。</li><li>创建一个新的字符串值可能需要0，1或2次动态分配内存。</li><li>string对象可能共享，有可能不共享大小和容量信息。</li><li>string不一定支持针对单个对象的分配子。</li><li>不同实现对字符内存的最小分配单元要求不同。</li></ul><h3 id="第16条：了解如何把vector和string数据传给旧的API"><a href="#第16条：了解如何把vector和string数据传给旧的API" class="headerlink" title="第16条：了解如何把vector和string数据传给旧的API"></a>第16条：了解如何把vector和string数据传给旧的API</h3><p>对于vector，因为vector保证和数组有同样的内存布局，你可以直接把vector中的数据当作数组中的数据对待，那么只需使用&amp;v[0]即可，不过注意v不能是空的，为了避免错误，你可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!v.empty())&#123;</span><br><span class="line">    c_api(&amp;v[<span class="number">0</span>],v.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于string，上面的方式不可行，因为string中的数据不一定存储在连续的内存中，且string的内部表示不一定是以空字符结尾的。你可以调用c_str()成员函数。</p><p>由于传给API的都是指针，所以理论上是可以改变原数据的，不过，对于string来说，API不应更改它的数据，因为c_str产生的指针未必指向字符串数据的内部表示，也可能指向字符串数据的一个不可修改的拷贝。</p><p>而对于vector来说，API更改元素值通常没什么问题，但不要试图改变元素的个数，这会使vector无法得知自己的正确大小从而发生错误。</p><p>别忘了，vector保证和数组有同样的内存布局，所以如果想把vector和string之外的STL容器中的数据传递给C API，你可以把每个元素都拷贝到一个vector中再把这个vector中的数据传递给C API。</p><h3 id="第17条：使用“swap技巧”除去多余的容量"><a href="#第17条：使用“swap技巧”除去多余的容量" class="headerlink" title="第17条：使用“swap技巧”除去多余的容量"></a>第17条：使用“swap技巧”除去多余的容量</h3><p>如果你向一个vector中添加了10000个元素，然后删除其中的9990个元素，这时vector中还剩10个元素，虽然容器的size减小了，可它的capacity并没有减小，怎样把多余的capacity除去呢？可以像下面这么写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表达式vector&lt;int&gt;(data)创建一个临时vector，它是data的拷贝，</span></span><br><span class="line"><span class="comment">//由拷贝构造函数完成，只为拷贝的元素分配内存，除去了多余的capacity，</span></span><br><span class="line"><span class="comment">//然后调用swap交换临时vector和原vector的内容</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(data).swap(data);</span><br></pre></td></tr></table></figure><p>以上称之为shrink to fit，不过在拷贝时，STL实现可以为容器保留多余的容量（比如容量为2的乘幂数），因而这不一定能把所有的多余空间都除去。</p><p>类似，以下代码可以清空容器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;().swap(data);</span><br></pre></td></tr></table></figure></p><p>顺带一提，swap操作不会使迭代器、指针和引用失效，它们依然指向原来的元素，只是元素的位置已经变了。</p><p>PS：C++11已为deque、string、vector提供了shrink_to_fit成员函数，功能与本节一致，不过能否将capacity()减少到size()仍然依赖实现，并可能发生重分配。</p><h3 id="第18条：避免使用vector-lt-bool"><a href="#第18条：避免使用vector-lt-bool" class="headerlink" title="第18条：避免使用vector&lt;bool>"></a>第18条：避免使用vector&lt;bool></h3><p>首先明确，vector&lt;bool>不是一个STL容器，其次它也不存储bool，其他一切正常。</p><p>为什么说vector&lt;bool>不是一个STL容器？因为下面的代码无法通过编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; c(<span class="number">50</span>);</span><br><span class="line"><span class="keyword">bool</span>* p = &amp;c[<span class="number">0</span>];<span class="comment">//无法通过编译</span></span><br></pre></td></tr></table></figure><p>Why？因为vector&lt;bool>为了节省空间，它并不真的存储bool，而 是类似位域的思想，存储在vector&lt;bool>中的每一个“bool”仅占一个二进制位，一个8位的字节可容纳8个“bool”。创建指向一个bool的指针是被允许的，但创建指向单个位的指针是不允许的。</p><p>指向单个位的引用也是被禁止的，那么，vector&lt;bool>怎么解决operator[]应该返回T&amp;的问题？它采用了代理对象的概念，也就是说，vector&lt;bool>::operator[]实际上返回一个对象，这个对象表现得像一个指向单个位的引用，大概像下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模版偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Allocator&gt;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>, Allocator&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">reference</span> &#123;</span>...&#125;;<span class="comment">//代理对象类</span></span><br><span class="line">    reference <span class="keyword">operator</span>[]*(size_type n);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么，下面代码为何不能通过编译就好理解了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; c(<span class="number">50</span>);</span><br><span class="line"><span class="keyword">bool</span>* p = &amp;c[<span class="number">0</span>];<span class="comment">//右侧类型实际上是vector&lt;bool&gt;::reference*</span></span><br></pre></td></tr></table></figure><p>既然vector&lt;bool>不是一个STL容器，它为何还出现在C++标准中呢？原因是因为一个雄心勃勃的实验：</p><pre><code>代理对象在C++软件开发中经常会很有用，而C++标准委员会的人很清楚这一点，于是他们决定开发vector&lt;bool&gt;来演示STL如何支持“通过代理来存取其元素的容器”，他们认为，C++标准中有了这个例子，人们就在实现自己的基于代理的容器时就有了现成的参考。然而，他们却发现，要创建一个基于代理的容器，又要求它满足STL容器的所有要求是不可能的，由于种种原因，这个失败的尝试遗留在了标准中:(</code></pre><p>所以，最好不要使用vector&lt;bool>，如果你想要一个bool的容器，你可以选择deque&lt;bool>，如果你想对位进行操作，可以选择bitset。</p><h2 id="三-关联容器"><a href="#三-关联容器" class="headerlink" title="三.关联容器"></a>三.关联容器</h2><h3 id="第19条：理解相等和等价的区别"><a href="#第19条：理解相等和等价的区别" class="headerlink" title="第19条：理解相等和等价的区别"></a>第19条：理解相等和等价的区别</h3><p>STL中比较操作随处可见，代表性的是find算法和set::insert，不过这两个对“相同”的定义不同：</p><ul><li>find对相同的定义为“相等”，基于operator==。</li><li>set::insert对相同的定义为“等价”，基于operator&lt;。</li></ul><p>相等的概念很明确，就是 x==y 。</p><p>而等价的概念为，!(x&lt;y) &amp;&amp; !(y&lt;x)，通常等价关系是以“在已排序的区间中对象的相对顺序”为基础的，想想关联容器的排列关系，这很有用：两个同类型对象x和y，仅根据对象中一种数据进行排序（比如对年龄而不对身高排序），那么，x与y等价可不意味着x与y相等。</p><p>再举个例子，假设考虑一个不区分大小写的set&lt;string>，则当你这样做时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>,cistring&gt; s;<span class="comment">//cistring为不区分大小写的比较类</span></span><br><span class="line">s.insert(<span class="string">"hello"</span>);<span class="comment">//一个新元素被插入s</span></span><br><span class="line">s.insert(<span class="string">"HElLo"</span>);<span class="comment">//没有新元素被插入s，HElLo与hello等价</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//调用set::find：</span></span><br><span class="line">s.find(<span class="string">"hEllO"</span>) != s.end()；<span class="comment">//查找会成功，这个表达式为真</span></span><br><span class="line"><span class="comment">//调用find算法：</span></span><br><span class="line">find(s.begin(), s.end(), <span class="string">"hEllO"</span>) != s.end();<span class="comment">//查找失败，表达式为假</span></span><br></pre></td></tr></table></figure><p>上面的现象说明了：set等标准关联容器基于“等价”，而find算法基于“相等”。</p><p>为什么标准关联容器要基于等价呢？如果它基于相等，由于标准关联容器总是保持顺序的，那么它就需要两个函数：比较函数确定顺序，相等函数判定相等。然后遇到这种情况：两个年龄相等而身高不同的对象，相等函数判定肯定是不相等，所以它们两个都可以插入容器，而比较函数按照年龄排序，由于年龄相等，无法判断顺序，它们究竟谁在前谁在后？（事实上，multiset和multimap就是这样的，等价的值是无法确定顺序的，所以你无法以确定的顺序遍历这种容器）而“等价”则可以避免“相等”带来的一堆问题。</p><p>另外，对于非标准的非排序性关联容器（hash_map等），等价和相等都有可能被使用。</p><h3 id="第20条：为包含指针的关联容器指定比较类型"><a href="#第20条：为包含指针的关联容器指定比较类型" class="headerlink" title="第20条：为包含指针的关联容器指定比较类型"></a>第20条：为包含指针的关联容器指定比较类型</h3><p>如果你这样写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*&gt; s;</span><br><span class="line">s.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Aaa"</span>));</span><br><span class="line">s.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Ccc"</span>));</span><br><span class="line">s.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Bbb"</span>));</span><br><span class="line">s.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Ggg"</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = s.begin(); i != s.end(); ++i)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你觉得结果会是什么？结果是一堆十六进制数——那是指针的值，别忘了，set里存的是指针。</p><p>而如果把<em>i换成**i，结果也未必是你想要的，因为此时set中的比较函数是less&lt;string\</em>>，你觉得less&lt;string*>是怎样比较指针？对指针解引用然后比较string？不，它只是简单地对指针的值进行比较:(</p><p>为了让s中的元素正确排序，请提供自定义比较类型，像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">string_cmp</span>:</span></span><br><span class="line">    <span class="comment">//继承此基类的原因请查看第40条</span></span><br><span class="line">    pubilc binary_function&lt;<span class="keyword">const</span> <span class="built_in">string</span>*,</span><br><span class="line">                           <span class="keyword">const</span> <span class="built_in">string</span>*,</span><br><span class="line">                           <span class="keyword">bool</span>&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>* l, <span class="keyword">const</span> sting* r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *l&lt;*r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*, string_cmp&gt; s;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意，请提供一个<strong>比较类型</strong>，不要妄想这样做：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>* l, <span class="keyword">const</span> sting* r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *l&lt;*r;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*, cmp&gt; s;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>上面的代码不会通过编译，cmp只是一个函数名，而提供给set模版的必须是一个类型名，set需要一个<strong>比较类型</strong>，并创建一个该比较类型的函数（对象）。</p><p>另外，尽管本条针对的是指针，但实际上，对于包含对象和指针行为类似（如智能指针、迭代器）的关联容器也适用。</p><h3 id="第21条：总是让比较函数在等值情况下返回false"><a href="#第21条：总是让比较函数在等值情况下返回false" class="headerlink" title="第21条：总是让比较函数在等值情况下返回false"></a>第21条：总是让比较函数在等值情况下返回false</h3><p>出个小问题，看下面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, less_equal&lt;<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">s.insert(<span class="number">10</span>);</span><br><span class="line">s.insert(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>问：10插入了几次？答：2次。</p><p>别忘了，标准关联容器是基于等价的，也就是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!(x&lt;y) &amp;&amp; !(y&lt;x)</span><br></pre></td></tr></table></figure></p><p>那么在上面的问题中，实际上进行的是下面的判断：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!(<span class="number">10</span>&lt;=<span class="number">10</span>) &amp;&amp; !(<span class="number">10</span>&lt;=<span class="number">10</span>) <span class="comment">//结果为false</span></span><br></pre></td></tr></table></figure></p><p>也就是说，10和10不等价！所以请把比较函数定义为&lt;而不是&lt;=，即让比较函数在等值情况下返回false。</p><p>嘿！multimap和multiset允许添加重复元素，上面的问题对于multiset，multimap不存在的吧？</p><p>不不不，还是存在的，假设你一开始这样写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, less_equal&lt;<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">s.insert(<span class="number">10</span>);</span><br><span class="line">s.insert(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p><p>当你对s调用equal_range，你期望得到一对迭代器，这个迭代器区间一定只包含这两个10，但问题是，equal_range得到的区间里的值一定都是等价的，所以你得不到你期望的迭代器区间。</p><p>从技术来说，用于对关联容器排序的比较函数必须为它们所比较的元素定义一个“严格弱序”（传给sort之类的算法的比较函数也有这个要求），严格弱序意味着什么？不要管太多细节，只记住一点，任何一个定义了“严格弱序”的函数对于两个相同的值比较都返回false，这正是本条所告诉你的。</p><h3 id="第22条：切勿直接修改set或者multiset中的键"><a href="#第22条：切勿直接修改set或者multiset中的键" class="headerlink" title="第22条：切勿直接修改set或者multiset中的键"></a>第22条：切勿直接修改set或者multiset中的键</h3><p>因为set和multiset中的元素是有序存放的，所以你不能直接修改键，这会破坏顺序。</p><p>对于map和multimap来说，因为其元素的类型为pair<const k,="" v\="">，直接更改键甚至不可能通过编译。</const></p><p>如果你放进set中的每个对象都是一组数据的集合（struct），而只有其中的一个数据充当了键，那么你可以更改对象的非键部分，不过这样做是不可移植的，标准规定了：set和map中的数据不应该在没有强制类型转换的情况下可被更改，所以有的STL实现不会允许你这样做。</p><p>运用强制类型转换进行更改要像下面这样写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">data</span>&#123;</span><span class="comment">//定义一个数据集合，以id为键</span></span><br><span class="line">pubilc:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setname</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">getname</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setage</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; age)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">getage</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;data&gt; s;</span><br><span class="line">...<span class="comment">//向s中插入若干元素</span></span><br><span class="line">s::iterator i = s.find(special_id);</span><br><span class="line"><span class="keyword">if</span>(i != s.end())&#123;</span><br><span class="line">    <span class="comment">//必须是const_cast&lt;data&amp;&gt;</span></span><br><span class="line">    <span class="keyword">const_cast</span>&lt;data&amp;&gt;(*i).setname(<span class="string">"Tom"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你这样写，会产生临时对象，从而与预期结果不符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;data&gt;(*i).setname(<span class="string">"Tom"</span>);</span><br></pre></td></tr></table></figure></p><p>上面的代码与下面的等价：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(data(*i)).setname(<span class="string">"Tom"</span>);</span><br></pre></td></tr></table></figure></p><p>然后和下面的等价：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">data <span class="title">temp</span><span class="params">(*i)</span></span>;</span><br><span class="line">temp.setname(<span class="string">"Tom"</span>);</span><br></pre></td></tr></table></figure></p><p>强制类型转换很危险，能避免就避免用它，如果你真的想安全可行地修改set、multiset、map、multimap中的元素，这样做：</p><ol><li>找到你想修改的元素；</li><li>为要修改的元素做一份拷贝，注意不要声明为const，你是想改变它；</li><li>修改拷贝使之具有你想要的值；</li><li>删除容器中的原元素，通常采用erase()；</li><li>将拷贝添加进容器，为了节省时间，可采用提示形式的insert。</li></ol><p>像这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s::iterator i = s.find(special_id);</span><br><span class="line"><span class="keyword">if</span>(i != s.end())&#123;</span><br><span class="line">    <span class="function">data <span class="title">temp</span><span class="params">(*i)</span></span>;</span><br><span class="line">    temp.setname(<span class="string">"Tom"</span>);</span><br><span class="line">    s.erase(i++);<span class="comment">//递增迭代器保证它的有效性</span></span><br><span class="line">    s.insert(i, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第23条：考虑用排序的vector替代关联容器"><a href="#第23条：考虑用排序的vector替代关联容器" class="headerlink" title="第23条：考虑用排序的vector替代关联容器"></a>第23条：考虑用排序的vector替代关联容器</h3><p>如果需要一个可供快速查找的容器，一般会想到标准关联容器，然而，如果查找速度非常重要，非标准散列容器更合适，而如果对数级别的查找速度对你来说刚刚好，有时用排序的vector代替关联容器会更好。</p><p>标准关联容器通常用红黑树（二叉平衡树）实现，并且是基于节点的容器，所以这意味着它查找速度是对数级别的，插入删除元素很方便，但由于要存储指向节点的指针，占用的内存空间比较大并且元素不是连续的（当数据量很大时，这可能会很慢）。</p><p>而vector中的元素是连续存储的，这使得存储相同的数据vector比标准关联容器占用内存要小，并且在对vector进行排序后，使用二分查找，它的查找速度也是对数级别。不过，向vector中插入删除元素后，插入删除位置后的所有元素都要移动，如果超出容器容量，vector还要重新分配内存。</p><p>那么，当查找操作不与插入删除操作混杂在一起，并且插入和删除不是很频繁的话，考虑到占用内存以及数据量很大时标准关联容器会比较慢，此时可用排序的vector替代关联容器。</p><p>另外，用vector替代map，multimap时有几点要注意：</p><ul><li>vector必须存储pair&lt;K, V>类型的对象，因为map中存储的是pair<const k,="" v\="">，去掉了const是因为排序时容器元素要进行赋值移动。</const></li><li>编写自己的排序函数，而且这个函数只对元素的键（K）排序。</li><li>编写两个查找函数（通过重载），每个查找函数都有两个参数，都为K和pair&lt;K, V>，不过顺序不同。这是因为，你查找时是按照键查找的，用键和容器中的pair对象做比较查找，你不知道第一个参数是键还是pair对象。</li></ul><h3 id="第24条：当效率至关重要时，请在map-operator-和map-insert之间谨慎选择"><a href="#第24条：当效率至关重要时，请在map-operator-和map-insert之间谨慎选择" class="headerlink" title="第24条：当效率至关重要时，请在map::operator[]和map::insert之间谨慎选择"></a>第24条：当效率至关重要时，请在map::operator[]和map::insert之间谨慎选择</h3><p>向map中添加一个元素，通常你有两种选择：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line">m[<span class="number">6</span>] = <span class="string">"A"</span>;</span><br></pre></td></tr></table></figure></p><p>或者：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">6</span>, <span class="string">"A"</span>));</span><br></pre></td></tr></table></figure></p><p>这种情况下，insert更快，map做了下面的事：</p><ol><li>先构造一个key为6，value为默认值的对象插入map。</li><li>为这个对象的value赋值”A”。</li></ol><p>赋值时，如果value类型没有定义特定的赋值函数，应该还会构造一个临时对象然后调用operator=函数赋值，然后析构临时对象，而insert直接用6，”A”构造了对象并插入map。</p><h3 id="第25条：熟悉非标准的散列容器"><a href="#第25条：熟悉非标准的散列容器" class="headerlink" title="第25条：熟悉非标准的散列容器"></a>第25条：熟悉非标准的散列容器</h3><p>很遗憾，之前STL并没有散列容器，不过有非标准的hash_set，hash_multiset，hash_map，hash_multimap可以用，你应该知道它们。</p><p>C++11已经添加了散列容器，不过被叫做unordered_xxx，这和hash_xxx有什么区别吗？老实说，除了名字不一样，一个是标准一个是非标准，它们的作用是一样的……由于hash_xxx在C++11前就有了，C++标准委员会为了区别它们，防止造成混乱，所以才取了unordered_xxx这个名字……</p><p>下面是stackoverflow的解答：</p><p><a href="https://stackoverflow.com/questions/1646266/difference-between-hash-map-and-unordered-map" target="_blank" rel="noopener">Difference between hash_map and unordered_map? — stackoverflow</a></p><pre><code>Since there was no hash table defined in the C++ standard library, different implementors of the standard libraries would provide a non-standard hash table often named hash_map. Because these implementations were not written following a standard they all had subtle differences in functionality and performance guarantees.Starting with C++11 a hash table implementation has been added to the C++ standard library standard. It was decided to use an alternate name for the class to prevent collisions with these non-standard implementations and to prevent inadvertent use of the new class by developers who had hash_table in their code.The chosen alternate name is unordered_map which really is more descriptive as it hints at the class&apos;s map interface and the unordered nature of its elements.</code></pre><h2 id="四-迭代器"><a href="#四-迭代器" class="headerlink" title="四.迭代器"></a>四.迭代器</h2><h3 id="第26条：iterator优先于const-iterator、reserve-iterator及const-reserve-iterator"><a href="#第26条：iterator优先于const-iterator、reserve-iterator及const-reserve-iterator" class="headerlink" title="第26条：iterator优先于const_iterator、reserve_iterator及const_reserve_iterator"></a>第26条：iterator优先于const_iterator、reserve_iterator及const_reserve_iterator</h3><p>STL为所有标准容器都提供了4种迭代器，他们的关系如下：</p><p><img src="/effective_stl_note/effective-stl-note/1.png" alt=""></p><p>为什么要优先使用iterator？</p><ul><li>有些版本的insert和erase函数要求使用iterator，其他迭代器类型不满足这些函数的要求。</li><li>隐式将const_iterator转换为iterator是不可能的。</li><li>从reserve_iterator转换而来的iterator在使用前可能需要相应调整。</li></ul><h3 id="第27条：使用distance和advance将容器的const-iterator转换为iterator"><a href="#第27条：使用distance和advance将容器的const-iterator转换为iterator" class="headerlink" title="第27条：使用distance和advance将容器的const_iterator转换为iterator"></a>第27条：使用distance和advance将容器的const_iterator转换为iterator</h3><p>如何把const_iterator转换为iterator？强制类型转换？</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator        Iter;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator  CIter;</span><br><span class="line"></span><br><span class="line">CIter ci;</span><br><span class="line">Iter i(const_cast&lt;Iter&gt;(ci));</span><br></pre></td></tr></table></figure><p>这很可能根本无法通过编译，因为iterator和const_iterator可能是两个完全不同的类，这种转换毫无意义。</p><p>应该这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator        Iter;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator  CIter;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">CIter ci;</span><br><span class="line">...      <span class="comment">//让ci指向v</span></span><br><span class="line">Iter i(v.begin());</span><br><span class="line"><span class="comment">//distance必须写成distance&lt;CIter&gt;</span></span><br><span class="line">advance(i, distance&lt;CIter&gt;(i, ci));</span><br></pre></td></tr></table></figure><p>distance函数是一个模板函数，并且参数的类型是相同的，如果你传给它两个不同类型的参数，会有二义性，编译器将无法对它实例化，需要显式指明类型参数。</p><p>另外，这种方法可能对于某些容器无效，并且效率取决于迭代器的类型，总的来说，尽可能避免const_iterator向iterator的转换。</p><h3 id="第28条：正确理解由reverse-iterator的base-成员函数所产生的iterator的用法"><a href="#第28条：正确理解由reverse-iterator的base-成员函数所产生的iterator的用法" class="headerlink" title="第28条：正确理解由reverse_iterator的base()成员函数所产生的iterator的用法"></a>第28条：正确理解由reverse_iterator的base()成员函数所产生的iterator的用法</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.reserve(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line">    v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator ri = </span><br><span class="line">    find(v.rbegin(), v.rend(), <span class="number">3</span>);</span><br><span class="line">vector&lt;int&gt;::iterator i(ri.base());</span><br></pre></td></tr></table></figure><p>以上代码执行完后，vector和迭代器的位置应该如下：</p><p><img src="/effective_stl_note/effective-stl-note/2.png" alt=""></p><p>此时，如果你想在ri指向的位置插入元素，由于某些容器insert仅接受iterator，你需要将ri.base()传递给它，插入是在迭代器之前，对reverse_iterator来说，也就是之后，所以插入操作对于ri和ri.base()是等价的。</p><p>不过如果你想删除元素的话，想想ri和ri.base()的位置：</p><p><img src="/effective_stl_note/effective-stl-note/3.png" alt=""></p><p>这时候他们就不等价了，你需要对ri.base()做一些更改，不过，C和C++规定了从函数返回的指针不应该更改，所以这样的代码对于用指针做迭代器实现的vector和string应该不能通过编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.erase(--ri.base());</span><br></pre></td></tr></table></figure><p>你应该这样写才对：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.erase((++ri).base());</span><br></pre></td></tr></table></figure></p><h3 id="第29条：对于逐个字符的输入请考虑使用istreambuf-iterator"><a href="#第29条：对于逐个字符的输入请考虑使用istreambuf-iterator" class="headerlink" title="第29条：对于逐个字符的输入请考虑使用istreambuf_iterator"></a>第29条：对于逐个字符的输入请考虑使用istreambuf_iterator</h3><p>如果你想把一个文本文件复制到一个string中，像下面这么写是不对的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">inputfile</span><span class="params">(<span class="string">"data.txt"</span>)</span></span>;</span><br><span class="line">string fileData((istream_iterator&lt;char&gt;(inputfile)),</span><br><span class="line">                 istream_iterator&lt;<span class="keyword">char</span>&gt;() );</span><br></pre></td></tr></table></figure><p>istream_iterator使用operator&gt;&gt;函数完成读操作，这会跳过文件中的所有空白字符。</p><p>这样写会保留空白字符，但速度会很慢：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">inputfile</span><span class="params">(<span class="string">"data.txt"</span>)</span></span>;</span><br><span class="line">inputfile.unsetf(ios::skipws);</span><br><span class="line">string fileData((istream_iterator&lt;char&gt;(inputfile)),</span><br><span class="line">                 istream_iterator&lt;<span class="keyword">char</span>&gt;() );</span><br></pre></td></tr></table></figure><p>因为每次调用operator&gt;&gt;都会执行很多附加操作。</p><p>所以，使用istreambuf_iterator，它不会跳过任何字符，只是简单地取回流缓冲区的下一个字符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">inputfile</span><span class="params">(<span class="string">"data.txt"</span>)</span></span>;</span><br><span class="line">string fileData((istreambuf_iterator&lt;char&gt;(inputfile)),</span><br><span class="line">                 istreambuf_iterator&lt;<span class="keyword">char</span>&gt;() );</span><br></pre></td></tr></table></figure><p>这样速度会比istream_iterator快很多，不过你就无法进行格式控制了，但本来也不需要进行格式控制。</p><p>同样，对于非格式化的字符输出，考虑用ostreambuf_iterator代替ostream_iterator。</p><h2 id="五-算法"><a href="#五-算法" class="headerlink" title="五.算法"></a>五.算法</h2><h3 id="第30条：确保目的区间足够大"><a href="#第30条：确保目的区间足够大" class="headerlink" title="第30条：确保目的区间足够大"></a>第30条：确保目的区间足够大</h3><p>如果你使用的算法需要指定一个目的区间，请确保目的区间足够大，或者确保它会随着算法的运行而不断增大（可以通过使用插入型迭代器完成，比如ostream_iterator，或者back_inserter、front_inserter、inserter返回的迭代器）。</p><p>注意，这里的足够大指的是容器的大小，而不是容量，算法是无法直接更改容器的大小和容量的，它只能对容器中的元素进行操作，比如移动拷贝复制。假设容器中有足够的容量，但它的大小并不足够容纳算法的结果，那么算法就会在容器已经分配了但还未使用的内存中“创建对象”，先不管程序能不能正确运行，即使算法真的成功创建了对象，容器的大小也不会改变（因为这不是通过正常途径添加的元素，容器无法得知究竟是谁添加的、添加了多少个元素），那么容器的end迭代器指的不可能是容器的实际end位置，于是便破坏了容器。</p><h3 id="第31条：了解各种与排序有关的选择"><a href="#第31条：了解各种与排序有关的选择" class="headerlink" title="第31条：了解各种与排序有关的选择"></a>第31条：了解各种与排序有关的选择</h3><p>根据容器的不同，功能的不同，选择如下：</p><ul><li>对vector、string、deque或数组中的元素完全排序，使用sort或stable_sort。</li><li>对vector、string、deque或数组中等价性最前面的n个元素排序，使用partial_sort。</li><li>对vector、string、deque或数组中的元素，需要找到第n个位置上的元素或者找到等价性最前面的n个元素但不需要对这n个元素排序，使用nth_element。</li><li>将一个标准序列容器的元素按照某种特定条件划分开，使用partition或stable_partition。</li><li>对list中的元素，可以直接使用partition和stable_partition，而sort、stable_sort、nth_element、partial_sort无法使用。可以用list::sort代替sort和stable_sort，如果想获得ntn_element或partial_sort的效果，可以将list中的元素复制到一个提供随机访问迭代器的容器里，再对这个容器进行操作或者创建一个list::iterator的容器，再对这个容器进行操作并通过其中的迭代器访问list中的元素。</li></ul><p>这些算法对迭代器的要求：</p><ul><li>sort、stable_sort、partial_sort、nth_element算法要求随机访问迭代器。</li><li>partition和stable_partition算法要求双向迭代器。</li></ul><p>算法性能排名：</p><ol><li>partition</li><li>stable_partition</li><li>nth_element</li><li>partial_sort</li><li>sort</li><li>stable_sort</li></ol><h3 id="第32条：如果确实需要删除元素，则需要在remove这一类算法之后调用erase"><a href="#第32条：如果确实需要删除元素，则需要在remove这一类算法之后调用erase" class="headerlink" title="第32条：如果确实需要删除元素，则需要在remove这一类算法之后调用erase"></a>第32条：如果确实需要删除元素，则需要在remove这一类算法之后调用erase</h3><p>如何从容器中删除元素？唯一的办法就是调用容器的成员函数（这几乎总是erase的某种形式），算法是不可能直接删除容器中的元素的，而remove一类从容器中删除元素的算法并不是真正意义上的删除，它们只是把不用被删除的元素移到了区间的前面（保持它们的相对位置），返回一个指向最后一个“不用被删除”的元素之后的元素的迭代器，像下面这样：</p><p>调用remove前：</p><p><img src="/effective_stl_note/effective-stl-note/4.png" alt=""></p><p>调用remove：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator newEnd(remove(v.begin(), v.end(), 99));</span><br></pre></td></tr></table></figure></p><p>调用remove后：</p><p><img src="/effective_stl_note/effective-stl-note/5.png" alt=""></p><p>注意，并不是应该被删除的元素被移到了容器末尾，只是区间的前面一定是不用被删除的元素，调用remove后v的布局很可能像下面这样：</p><p><img src="/effective_stl_note/effective-stl-note/6.png" alt=""></p><p>有关上图的解释，remove可以看做一个压缩过程，算法从前向后扫描，扫描到要被删除的元素，便用后面的元素覆盖它，直至扫描完成（如果容器里存的是指针可能就会出现问题了，见第33条），像这样：</p><p><img src="/effective_stl_note/effective-stl-note/7.png" alt=""></p><p>因此，如果你真的想删除元素，请调用区间形式的erase，像这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line">v.erase(remove(v.begin(), v.end(), <span class="number">99</span>), v.end());</span><br></pre></td></tr></table></figure><p>除了remove外，remove_if，unique也与之类似，请把它们和erase联合使用来真正地删除容器中的元素。</p><h3 id="第33条：对包含指针的容器使用remove这一类算法时要特别小心"><a href="#第33条：对包含指针的容器使用remove这一类算法时要特别小心" class="headerlink" title="第33条：对包含指针的容器使用remove这一类算法时要特别小心"></a>第33条：对包含指针的容器使用remove这一类算法时要特别小心</h3><p>正如第32条所说的，remove一类的算法会对容器中的元素进行覆盖，那么如果你动态分配了一些对象，并把这些对象的指针存放在一个容器里，当你想删除符合某种条件的对象时，你首先考虑到你要delete指针而不是仅仅删除指针来防止内存泄露，于是你想调用remove_if筛选出符合条件的指针，然后delete末尾的指针，可当你调用remove_if时，由于remove_if是通过覆盖工作的，末尾的指针并不一定是你要删除的元素，你不仅发生了内存泄露，还delete了不应该delete的指针:(</p><p>为了避免这种情况，可以先遍历容器delete你要delete的指针，并把它们设置为nullptr，然后用erase-remove方法删除容器中的nullptr。或者，在容器中存放智能指针，这样你就可以直接使用erase-remove方法，不必再考虑内存泄漏问题。</p><h3 id="第34条：了解哪些算法要求使用排序的区间作为参数"><a href="#第34条：了解哪些算法要求使用排序的区间作为参数" class="headerlink" title="第34条：了解哪些算法要求使用排序的区间作为参数"></a>第34条：了解哪些算法要求使用排序的区间作为参数</h3><p>先列出需要排序区间的11个算法：</p><ol><li>binary_search</li><li>lower_bound</li><li>upper_bound</li><li>equal_range</li><li>set_union</li><li>set_intersection</li><li>set_difference</li><li>set_symmetric_difference</li><li>merge</li><li>inplace_merge</li><li>includes</li></ol><p>这11个算法之所以要求排序的区间，就是为了提供更好的性能，具体看一下为什么：</p><ul><li>binary_search、lower_bound、upper_bound、equal_range提供对数查找效率，用二分法查找数据，所以要求排序区间（实际上当迭代器不是随机迭代器时，由于此时元素只能一个一个移动，所以是线性时间效率）。</li><li>set_union、set_intersection、set_difference、set_symmtric_difference提供线性时间效率的集合操作，因此需要排序区间。</li><li>merge、inplace_merge提供线性时间效率，合并两个排序区间为一个新的排序区间。</li></ul><p>除了这11个之外，unique和unique_copy虽然不一定要求排序的区间，但通常和排序区间一起使用。这是因为unique<strong>删除每一组连续相等的元素并仅保留其中的第一个</strong>，也就是说，如果你想删除区间里所有重复的元素，你必须排序。</p><p>现在说一说“排序区间”意味着什么，这意味着你如果提供给了排序函数一个自定义的比较函数，你也必须为那11个函数提供相同的比较函数，不然，它们无法知道你究竟是怎样对元素排序的，会默认升序排列。</p><p>所有这11个算法均用<strong>等价</strong>判断两个对象是否相等，unique和unique_copy默认使用<strong>相等</strong>判断，但你可以传递给它们一个自定义比较函数来改变<strong>相等</strong>的定义来实现<strong>等价</strong>的概念。</p><h3 id="第35条：通过mismatch或lexicographical-compare实现简单的忽略大小写的字符串比较"><a href="#第35条：通过mismatch或lexicographical-compare实现简单的忽略大小写的字符串比较" class="headerlink" title="第35条：通过mismatch或lexicographical_compare实现简单的忽略大小写的字符串比较"></a>第35条：通过mismatch或lexicographical_compare实现简单的忽略大小写的字符串比较</h3><p>不考虑国际化，有两种办法实现，第一种方法使用mismatch：</p><p>首先先写一个判断字符相等的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">char_cmp</span><span class="params">(<span class="keyword">char</span> c1, <span class="keyword">char</span> c2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lc1 = <span class="built_in">tolower</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(c1));</span><br><span class="line">    <span class="keyword">int</span> lc2 = <span class="built_in">tolower</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(c2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lc1 &lt; lc2)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(lc1 &gt; lc2)   ruturn <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再通过mismatch编写比较字符串的函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">string_cmp_impl</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>;<span class="comment">//先声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">string_cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//把短的字符串作为第一个参数传入，交换位置需要加负号</span></span><br><span class="line">    <span class="keyword">if</span>(s1.size() &lt;= s2.size())  <span class="keyword">return</span> string_cmp_impl(s1, s2);</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> - string_cmp_impl(s2,s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">string_cmp_impl</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">    pair&lt;<span class="built_in">string</span>::const_iterator,</span><br><span class="line">         <span class="built_in">string</span>::const_iterator&gt; p =</span><br><span class="line">        mismatch(s1.begin(), s1.end(), s2.begin(),</span><br><span class="line">                not2(ptr_fun(char_cmp)));      <span class="comment">//char_cmp函数在字符相等时返回0</span></span><br><span class="line">                                               <span class="comment">//0转换为false而不是true，加not2取反</span></span><br><span class="line">    <span class="keyword">if</span>(p.first == s1.end())&#123;                   <span class="comment">//如果为true</span></span><br><span class="line">        <span class="keyword">if</span>(p.second == s2.end())    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//要么s1和s2相等</span></span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">-1</span>；                    <span class="comment">//要么s1比s2短</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> char_cmp(*p.first, *p.second);      <span class="comment">//字符串的关系和这两个</span></span><br><span class="line">&#125;                                              <span class="comment">//不匹配的字符关系相同</span></span><br></pre></td></tr></table></figure></p><p>第二种方法使用lexicographical_compare：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">char_less</span><span class="params">(<span class="keyword">char</span> c1, <span class="keyword">char</span> c2)</span></span>&#123;       <span class="comment">//返回在忽略大小写的前提下</span></span><br><span class="line">    <span class="keyword">return</span>                              <span class="comment">//c1是否在c2之前</span></span><br><span class="line">        <span class="built_in">tolower</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(c1)) &lt;</span><br><span class="line">        <span class="built_in">tolower</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(c2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">string_cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lexicographical_compare(s1.begin(), s1.end(),</span><br><span class="line">                                   s2.begin(), s2.end(),</span><br><span class="line">                                   char_less);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lexicographical_compare的功能是：接受一个判别式，由这个判别式决定两个值的顺序，比较方法和strcmp类似。</p><h3 id="第36条：理解copy-if算法的正确实现"><a href="#第36条：理解copy-if算法的正确实现" class="headerlink" title="第36条：理解copy_if算法的正确实现"></a>第36条：理解copy_if算法的正确实现</h3><p>STL中，有11个名字中有copy的算法：</p><ol><li>copy</li><li>copy_backward</li><li>replace_copy</li><li>replace_copy_if</li><li>remove_copy</li><li>remove_copy_if</li><li>uninitialized_copy</li><li>reverse_copy</li><li>unique_copy</li><li>rotate_copy</li><li>partial_sort_copy</li></ol><p>这其中没有copy_if，意味着你如果想简单地复制某个区间里满足某个判别式的所有元素，需要自己实现。</p><p>曾经copy_if是在STL里的，但因为写copy_if价值不大，后来copy_if便被丢弃了:(</p><p>copy_if的一种不完美实现方法如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator,</span><br><span class="line">         <span class="keyword">typename</span> OutputIterator,</span><br><span class="line">         <span class="keyword">typename</span> Predicate&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">copy_if</span><span class="params">(InputIterator begin,</span></span></span><br><span class="line"><span class="function"><span class="params">                       InputIterator end,</span></span></span><br><span class="line"><span class="function"><span class="params">                       OutputIterator destBegin</span></span></span><br><span class="line"><span class="function"><span class="params">                       Predicate p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove_copy_if(begin, end, destBegin, not1(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了得到所有满足p的元素，只要去掉所有不满足p的元素就好了，用not1将判别式取反调用remove_copy_if即可。不过，这种实现方法是有缺陷的，如果你写一个函数，将它作为p传递给上面的函数，编译不会通过，因为not1不能应用于函数指针上，你需要ptr_fun函数来进行转换。为了调用上面的函数，你要传递的不仅是一个函数对象，还应该是一个可配接的函数对象（这很容易做到）。下面是一个完美的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator,</span><br><span class="line">         <span class="keyword">typename</span> OutputIterator,</span><br><span class="line">         <span class="keyword">typename</span> Predicate&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">copy_if</span><span class="params">(InputIterator begin,</span></span></span><br><span class="line"><span class="function"><span class="params">                       InputIterator end,</span></span></span><br><span class="line"><span class="function"><span class="params">                       OutputIterator destBegin</span></span></span><br><span class="line"><span class="function"><span class="params">                       Predicate p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(begin != end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p(*begin))   *destBegin++ = *begin;</span><br><span class="line">        ++begin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> destBegin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第37条：使用accumulate或者for-each进行区间统计"><a href="#第37条：使用accumulate或者for-each进行区间统计" class="headerlink" title="第37条：使用accumulate或者for_each进行区间统计"></a>第37条：使用accumulate或者for_each进行区间统计</h3><p>有时候，你需要对某个区间做一些操作，比如count告诉你区间里有多少个元素、count_if告诉你满足判别式的元素个数、min_element和max_element获得区间里的最小最大值。如果你想按照自定义的方式对区间统计处理，accumulate是你所需要的（注意，accumulate在头文件&lt;numeric>而不是&lt;algorithm>中）。</p><p>accumulate可以这样用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; l;</span><br><span class="line">...                                              <span class="comment">//添加一些double</span></span><br><span class="line"><span class="keyword">double</span> sum = accumulate(l.begin(), l.end(), <span class="number">0.0</span>) <span class="comment">//计算和，初始值为0.0</span></span><br></pre></td></tr></table></figure></p><p>注意，初始值必须是0.0，因为0.0的类型是double，这样accumulate内部会用一个double类型的变量保存计算的总和；而如果初始值是0，accumulate内部就会用一个int类型的变量保存计算的总和，结果肯定是不对的。</p><p>也许正是accumulate默认的这种用法使它归为numeric algorithm（数值算法），不过accumulate还可以再带一个任意的统计函数使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个统计字符串长度的函数</span></span><br><span class="line"><span class="built_in">string</span>::size_type </span><br><span class="line">string_len_sum(<span class="built_in">string</span>::size_type sum_now,       <span class="comment">//第一个参数为当前总和，</span></span><br><span class="line">               <span class="keyword">const</span> <span class="built_in">string</span>&amp; s)&#123;                <span class="comment">//第二个是下一个要统计的元素</span></span><br><span class="line">                   <span class="keyword">return</span> sum_now + s.size();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">...                                             <span class="comment">//加入一些数据</span></span><br><span class="line"><span class="built_in">string</span>::size_type lengthsum =                   <span class="comment">//对s中的每个元素调用</span></span><br><span class="line">    accumulate(s.begin(), s.end(),              <span class="comment">//string_len_sum，结果</span></span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="built_in">string</span>::size_type&gt;(<span class="number">0</span>),  <span class="comment">//赋给lengthsum，初始值为0</span></span><br><span class="line">            string_len_sum);</span><br></pre></td></tr></table></figure><p>来点有趣的，统计一个区间所有点的平均值，点结构如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    Point(<span class="keyword">double</span> initx, <span class="keyword">double</span> inity):x(initx), y(inity) &#123;&#125;</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>统计函数怎么写？大概像下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point_average</span>:</span></span><br><span class="line">    <span class="keyword">public</span> binary_function&lt;Point, Point, Point&gt;&#123;<span class="comment">//见第40条</span></span><br><span class="line">pubilc:</span><br><span class="line">    Point_average():xsum(<span class="number">0</span>), ysum(<span class="number">0</span>), num_point(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Point <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Point&amp; avg_now, <span class="keyword">const</span> Point&amp; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ++num_point;</span><br><span class="line">        xsum += p.x;</span><br><span class="line">        ysum += p.y;</span><br><span class="line">        <span class="keyword">return</span> Point(xsum/num_point, ysum/num_point);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> num_point;</span><br><span class="line">    <span class="keyword">double</span> xsum;</span><br><span class="line">    <span class="keyword">double</span> ysum;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">list</span>&lt;Point&gt; l;</span><br><span class="line">...</span><br><span class="line">Point avg = accumulate(l.begin(), l.end(),</span><br><span class="line">                       Point(<span class="number">0</span>, <span class="number">0</span>), Point_average());</span><br></pre></td></tr></table></figure><p>上面的代码看起来很棒，但是，标准规定传给accumulate的函数不能有副作用，而上面的函数对象修改了xsum、ysum、num_point，是有副作用的，所以行为未定义。</p><p>于是，我们可以转向for_each，传递给for_each的函数可以有副作用。因为for_each是将函数应用于区间的每一个元素，每次应用完后返回一个函数的拷贝，也就是最后会返回一个函数对象，所以我们需要能从这个函数对象中提取出我们所需要的信息。不过这样做，代码就没那么清晰了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point_average</span>:</span></span><br><span class="line">    <span class="keyword">public</span> unary_function&lt;Point, <span class="keyword">void</span>&gt;&#123;<span class="comment">//见第40条</span></span><br><span class="line">pubilc:</span><br><span class="line">    Point_average():xsum(<span class="number">0</span>), ysum(<span class="number">0</span>), num_point(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Point&amp; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ++num_point;</span><br><span class="line">        xsum += p.x;</span><br><span class="line">        ysum += p.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">result</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Point(xsum/num_point, ysum/num_point);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> num_point;</span><br><span class="line">    <span class="keyword">double</span> xsum;</span><br><span class="line">    <span class="keyword">double</span> ysum;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">list</span>&lt;Point&gt; l;</span><br><span class="line">...</span><br><span class="line">Point avg = for_each(l.begin(), l.end(),</span><br><span class="line">                        Point_average()).result();</span><br></pre></td></tr></table></figure><h2 id="六-函数子、函数子类、函数及其他"><a href="#六-函数子、函数子类、函数及其他" class="headerlink" title="六.函数子、函数子类、函数及其他"></a>六.函数子、函数子类、函数及其他</h2><h3 id="第38条：遵循按值传递的原则来设计函数子类"><a href="#第38条：遵循按值传递的原则来设计函数子类" class="headerlink" title="第38条：遵循按值传递的原则来设计函数子类"></a>第38条：遵循按值传递的原则来设计函数子类</h3><p>C和C++标准库函数，函数指针都是按值传递的，而在STL中，函数对象也是按值传递的（虽然你可以通过显式指明模板参数类型使它按照引用传递，但这样做并不好），所以你应该确保你编写的函数对象在经过了传递之后还能正常工作，这意味着：</p><ol><li>你的函数对象应尽可能地小，否则复制开销太大。</li><li>函数对象必须是单态的，如果它使用了虚函数，参数类型为基类，而实参是派生类，传递时就会发生剥离问题。</li></ol><p>但是，函数对象可以包含很多状态信息，并且如果使用多态可以很有用，为了解决这个矛盾，可以把数据和虚函数从函数子类分离出去放到一个新类中，并在函数子类中放一个指向新类对象的指针，这个技术很有用也很常用。</p><h3 id="第39条：确保判别式是“纯函数”"><a href="#第39条：确保判别式是“纯函数”" class="headerlink" title="第39条：确保判别式是“纯函数”"></a>第39条：确保判别式是“纯函数”</h3><p>判别式：一个返回bool类型的函数。</p><p>纯函数：返回值仅仅依赖于其参数的函数。</p><p>判别式类：operator()函数是一个判别式的函数子类。</p><p>记得第38条说的吗，函数对象都是按照值传递的，如果你的判别式不是“纯函数”，在其中有一些状态变量，那么它每次传递时都会复制一份，这很可能与你预想的结果不同。</p><h3 id="第40条：若一个类是函数子，则应使它可配接"><a href="#第40条：若一个类是函数子，则应使它可配接" class="headerlink" title="第40条：若一个类是函数子，则应使它可配接"></a>第40条：若一个类是函数子，则应使它可配接</h3><p>假设你想找到一个容器中满足特定条件的元素，你很可能像下面这么写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isboy</span><span class="params">(<span class="keyword">const</span> Person&amp; p)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> first_boy = find_if(v.begin(), v.end(), isboy);<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">auto</span> first_girl = find_if(v.begin(), v.end(), not1(isboy));<span class="comment">//错误，无法编译！</span></span><br></pre></td></tr></table></figure><p>你必须在应用not1之前先应用ptr_fun：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> first_girl = find_if(v.begin(), v.end(), not1(ptr_fun(isboy)));<span class="comment">//ok</span></span><br></pre></td></tr></table></figure></p><p>ptr_fun做了什么？它只是完成了一些类型定义的工作，但这些类型定义是not1所必需的。在STL中，4个标准函数配接器（not1、not2、bind1st、bind2nd）都有一些特殊的类型定义，非标准的与STL兼容的配接器也是如此，而提供了这些类型定义的函数对象被称为可配接的函数对象。如果你想让你的函数对象可以和STL协同工作，请让它们成为可配接的。</p><p>如何做呢？先来看看这些特殊的类型定义：argument_type、first_argument_type、second_argument_type、result_type等，这些只是其中的一些，除非你要编写自定义的配接器，你不需要过多了解它们，你只需要简单地继承一些基类并提供相应的模板参数即可：</p><ul><li>如果判别式只有一个参数，从std::unary_function继承，提供参数类型和返回类型。</li><li>如果判别式有两个参数，从std::binary_function继承，提供第一个参数类型、第二个参数类型和返回类型。</li></ul><p>有关提供的参数，还有一点点要说（不要追究为什么是这样）：</p><ul><li>如果参数类型是非指针类型，请提供去掉const和&amp;的参数。</li><li>如果参数类型是指针类型，请保留const和&amp;，提供完全一样的参数。</li></ul><p>另外，如果你想让你的函数子类具有多种不同的调用形式，那你就放弃了让其可配接的能力，不过有时候这的确有用。</p><h3 id="第41条：理解ptr-fun、mem-fun和mem-fun-ref的来由"><a href="#第41条：理解ptr-fun、mem-fun和mem-fun-ref的来由" class="headerlink" title="第41条：理解ptr_fun、mem_fun和mem_fun_ref的来由"></a>第41条：理解ptr_fun、mem_fun和mem_fun_ref的来由</h3><p>ptr_fun、mem_fun和mem_fun_ref的主要作用是为了解决C++语言中语法不一致的问题，比如说你有一个函数f和一个对象x，你想在x上调用f，那么你有三种写法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x);   <span class="comment">//#1. f是一个非成员函数</span></span><br><span class="line">x.f();  <span class="comment">//#2. f是x所在类的成员函数</span></span><br><span class="line">p-&gt;f(); <span class="comment">//#3. f是成员函数，并且p是指向x的指针</span></span><br></pre></td></tr></table></figure></p><p>现在有一个测试函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Widget&amp; w)</span></span>;</span><br></pre></td></tr></table></figure></p><p>一个存放Widget的容器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Widget&gt; v;</span><br></pre></td></tr></table></figure></p><p>你想对v中每一个对象都进行测试：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(v.begin(), v.end(), test); <span class="comment">//#1，可通过编译</span></span><br></pre></td></tr></table></figure></p><p>如果test是Widget的成员函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(v.begin(), v.end(), &amp;Widget::test); <span class="comment">//#2，无法通过编译</span></span><br></pre></td></tr></table></figure></p><p>如果对于存放Widget*的容器，理想状态下我们应该也能通过for_each调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;Widget*&gt; l;</span><br><span class="line">for_each(l.begin(), l.end(), &amp;Widget::test); <span class="comment">//#3，无法通过编译</span></span><br></pre></td></tr></table></figure></p><p>理想很美好，现实很残酷，for_each对于以上的三种调用方式需要三个版本，可实际上for_each只有一个版本，不难猜测它的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Function&gt;</span><br><span class="line"><span class="function">Function <span class="title">for_each</span><span class="params">(InputIterator begin, InputIterator end, Function f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (begin != end)    f(*begin++);</span><br><span class="line">    <span class="keyword">return</span>  f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是的，STL的惯例就是用#1的调用方式，而mem_fun和mem_fun_ref的作用就是为了调整成员函数使之能通过#1方式调用。像mem_fun和mem_fun_ref这样的类被称为函数对象配接器。</p><p>另外，ptr_fun、mem_fun和mem_fun_ref所产生的对象还提供了一些类型定义（见第40条）。</p><p>关于mem_fun和 mem_fun_ref的名字来由，这是一个历史遗留问题，接受它就好。</p><h3 id="第42条：确保less-lt-T-与operator-lt-具有相同的含义"><a href="#第42条：确保less-lt-T-与operator-lt-具有相同的含义" class="headerlink" title="第42条：确保less&lt;T>与operator&lt;具有相同的含义"></a>第42条：确保less&lt;T>与operator&lt;具有相同的含义</h3><p>对std名称空间中组件的修改是被禁止的，但是用户可以针对自己定义的类型特化std中的模板，如果你特化less模板，请务必确保你的特化版本和operator&lt;有相同的语义，因为C++假设less就是等价于operator&lt;的。</p><h2 id="七-在程序中使用STL"><a href="#七-在程序中使用STL" class="headerlink" title="七.在程序中使用STL"></a>七.在程序中使用STL</h2><h3 id="第43条：算法调用优先于手写的循环"><a href="#第43条：算法调用优先于手写的循环" class="headerlink" title="第43条：算法调用优先于手写的循环"></a>第43条：算法调用优先于手写的循环</h3><p>调用算法往往比手动编写一个循环要好：</p><ol><li>效率：算法通常比手写的循环效率高。</li><li>正确性：自己编写循环比起调用算法更容易出错。</li><li>可维护性：使用算法的代码比起手写循环的代码更简洁明了。</li></ol><p>从效率上讲，一方面，算法可以根据迭代器类型、容器类型对算法过程进行优化，另一方面，很多算法（比如sort）本身效率就是非常高的，一般人手写是达不到那种效率的。</p><p>从正确性讲，如果手写循环，最关键又最容易出错的问题就是考虑迭代器是否失效的问题，而调用算法，你只需要提供起始区间和其他一些简单的东西即可。</p><p>从可维护性讲，一个人看到算法名称，就可以知道它具体做了什么（即使不知道也可以查找算法的用途），而一个人看到循环，只能知道这是一个循环，想知道它具体做了什么必须把具体代码全部看完。</p><p>凡事都有例外，如果你想在一次迭代中表明自己做了什么工作，这时候手写循环要比算法好，因为这时候如果你调用算法，你所传递给算法的判别式可能很长，但你为这个判别式专门写一个函数子类又显得太小题大做并且阅读起来也不够方便；如果你在循环中做的工作很多，这时候为这些工作专门写一个函数子类并用算法调用就是可取并且推荐的。</p><h3 id="第44条：容器的成员函数优先于同名的算法"><a href="#第44条：容器的成员函数优先于同名的算法" class="headerlink" title="第44条：容器的成员函数优先于同名的算法"></a>第44条：容器的成员函数优先于同名的算法</h3><p>有些STL容器为你提供了一些与算法同名的成员函数，比如关联容器提供了count、find、lower_bound、upper_bound、equal_range，而iist提供了remove、remove_if、unique、sort、merge、reverse。大多数情况下你应该使用这些成员函数：</p><ol><li>成员函数的速度往往更快。</li><li>成员函数与容器结合得更加紧密。</li></ol><h3 id="第45条：正确区分count、find、binary-search、lower-bound、upper-bound和equal-range"><a href="#第45条：正确区分count、find、binary-search、lower-bound、upper-bound和equal-range" class="headerlink" title="第45条：正确区分count、find、binary_search、lower_bound、upper_bound和equal_range"></a>第45条：正确区分count、find、binary_search、lower_bound、upper_bound和equal_range</h3><p>如何选择这些算法？下面的表格总结了一切：</p><p><img src="/effective_stl_note/effective-stl-note/8.png" alt=""></p><h3 id="第46条：考虑使用函数对象而不是函数作为STL算法的参数"><a href="#第46条：考虑使用函数对象而不是函数作为STL算法的参数" class="headerlink" title="第46条：考虑使用函数对象而不是函数作为STL算法的参数"></a>第46条：考虑使用函数对象而不是函数作为STL算法的参数</h3><p>通常来说，操作对象比操作基本类型要慢，这很好理解，然而，将函数对象传递给STL算法往往比传递实际函数更高效，Why?</p><p>如果一个函数对象内部的operator()被声明为内联的，那么它的函数体可以直接被编译器使用，最终的结果是算法并不包括函数调用，然后编译器可以对这段没有包含函数调用的代码进行优化，而如果使用函数，要知道，从来都不能把真正的把一个函数作为参数传递给另一个函数，传递过去的只是一个函数指针，这样每次用到函数时都会产生一个间接的函数调用，即使把这个函数声明为内联的，大多数编译器也不会试图通过函数指针对函数调用进行内联优化，这就导致了函数对象的效率比函数要高。</p><p>除了效率问题外，使用函数对象作为STL算法参数可以避免一些奇怪的错误（可能由于语言的缺陷、编译器的缺陷或者STL库的问题）。</p><p>普通函数很实用，但当你使用STL时，函数对象更推荐使用。</p><h3 id="第47条：避免产生直写型代码"><a href="#第47条：避免产生直写型代码" class="headerlink" title="第47条：避免产生直写型代码"></a>第47条：避免产生直写型代码</h3><p>假如你想删除一个vector&lt;int>中所有值小于5的值，但在最后一个不小于8的元素前面的所有元素都应该保留下来，按照这句话的逻辑，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.erase(</span><br><span class="line">    remove_if(find_if(v.rbegin(), v.rend(),</span><br><span class="line">                      bind2nd(greater_equal&lt;<span class="keyword">int</span>&gt;(), <span class="number">8</span>))).base(),</span><br><span class="line">             v.end(),</span><br><span class="line">             bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">5</span>)),</span><br><span class="line">    v.end());</span><br></pre></td></tr></table></figure><p>这是最直截了当的代码，你可能能看懂，也可能看不懂，但是毫无疑问，这段代码并不易于维护，请避免这样写代码，让我们改一下上面的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//功能和上面完全一样</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">//初始化range_begin，使它指向v中最后一个不小于8的元素之后的元素</span></span><br><span class="line"><span class="comment">//如果不存在这样的元素，range_begin为v.begin()</span></span><br><span class="line"><span class="comment">//由于是reverse_iterator，最后用base()得到正向迭代器</span></span><br><span class="line"><span class="keyword">auto</span> range_begin = find_if(v.rbegin(), v.rend(),</span><br><span class="line">                           bind2nd(greater_equal&lt;<span class="keyword">int</span>&gt;(), <span class="number">8</span>)).base();</span><br><span class="line"><span class="comment">//在从range_begin到v.end()的区间里删除所有小于5的值</span></span><br><span class="line">v.erase(remove_if(range_begin, v.end(), </span><br><span class="line">                  bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">5</span>))</span><br><span class="line">        v.end());</span><br></pre></td></tr></table></figure></p><p>这样相信大部分人都能看懂，代码的可读性，可维护性是最重要的。</p><h3 id="第48条：总是包含（-include）正确的头文件"><a href="#第48条：总是包含（-include）正确的头文件" class="headerlink" title="第48条：总是包含（#include）正确的头文件"></a>第48条：总是包含（#include）正确的头文件</h3><p>如果你正在使用某个STL组件，请一定要提供相应的#include指令，下面是与标准STL有关的标准头文件中包含的内容：</p><ul><li>几乎所有的标准STL容器都被声明在与之同名的头文件中，不过multiset和multimap例外，它们分别被声明在&lt;set>和&lt;map>中。</li><li>除了4个STL算法外，其他所有算法都被声明在&lt;algorithm>中，这4个是accumulate、inner_product、adjacent_difference、partial_sum，它们被声明在&lt;numeric>中。</li><li>特殊类型的迭代器，包括istream_iterator和istreambuf_iterator，被声明在&lt;iterator>中。</li><li>标准的函数子和函数配接器被声明在<functional>中。</functional></li></ul><h3 id="第49条：学会分析与STL相关的编译器诊断信息"><a href="#第49条：学会分析与STL相关的编译器诊断信息" class="headerlink" title="第49条：学会分析与STL相关的编译器诊断信息"></a>第49条：学会分析与STL相关的编译器诊断信息</h3><p>由于STL里都是一些模板，所以出错时错误信息可能会很长很长……下面是一些关于错误信息的分析技巧：</p><ul><li>将一些类型定义的展开形式替换为你所熟悉的形式。</li><li>vector和string的迭代器通常就是指针，所以当错误使用了iterator时，错误信息中很可能会引用到指针类型。</li><li>如果错误信息中提到了back_insert_iterator、front_insert_iterator、insert_iterator、bind1st、bind2nd，几乎总意味着你错误地使用了它们。</li><li>输出迭代器在赋值操作符内部完成其输出或者插入操作，所以如果在使用这些迭代器时出错了，你看到的错误信息中可能会提到与赋值操作符有关的内容。</li><li>如果你看到的错误信息来源于某个STL算法的内部实现，有可能是你在调用算法时使用了错误的类型，比如说你使用了不恰当的迭代器类型。</li><li>如果你使用了一个很常见的STL组件，但是从错误信息找不到它的影子，很可能是你没有包含相应的头文件。</li></ul><h3 id="第50条：熟悉STL相关的Web站点"><a href="#第50条：熟悉STL相关的Web站点" class="headerlink" title="第50条：熟悉STL相关的Web站点"></a>第50条：熟悉STL相关的Web站点</h3><p>比如说：</p><ul><li>SGI STL</li><li>Boost</li><li>STLport</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用Hexo和Github Pages搭建属于你自己的博客</title>
      <link href="/hexo_github_blog/"/>
      <url>/hexo_github_blog/</url>
      
        <content type="html"><![CDATA[<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><pre><code>系统：Ubuntu 16.04 LTS所需软件：Node.js、Git、Hexo</code></pre><h2 id="大致步骤"><a href="#大致步骤" class="headerlink" title="大致步骤"></a>大致步骤</h2><ol><li>Node.js的安装</li><li>Git的安装和配置</li><li>Hexo的安装和配置</li><li>Github的配置</li><li>博客的部署</li><li>如何编辑和发布博客</li><li>挑选一个Hexo主题</li></ol><a id="more"></a><h2 id="Node-js的安装"><a href="#Node-js的安装" class="headerlink" title="Node.js的安装"></a>Node.js的安装</h2><p>建议通过nvm(Node Version Manager)安装，nvm可以通过参照<a href="https://github.com/creationix/nvm/blob/master/README.md" target="_blank" rel="noopener">nvm文档</a>进行安装，这里直接给出安装方法：</p><ul><li><p>using cURL:</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</span><br></pre></td></tr></table></figure></li><li><p>using Wget：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</span><br></pre></td></tr></table></figure></li></ul><p>nvm安装后，如果终端提示找不到nvm命令，请使用source命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></p><p>如果是zsh，请使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></p><p>nvm安装完成后，运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install stable</span><br></pre></td></tr></table></figure></p><p>安装Node.js，然后运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v &amp;&amp; npm -v</span><br></pre></td></tr></table></figure></p><p>检查是否成功安装了Node.js和npm。</p><h2 id="Git的安装和配置"><a href="#Git的安装和配置" class="headerlink" title="Git的安装和配置"></a>Git的安装和配置</h2><p>运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git-core</span><br></pre></td></tr></table></figure></p><p>即可安装git，然后对git进行简单配置：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "yourname"</span><br><span class="line">git config --global user.email "youremail"</span><br></pre></td></tr></table></figure></p><p>然后生成ssh密钥：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></p><p>生成时它会让你选择密钥文件的存储位置以及让你设置密码，建议全部选择默认设置（全部直接回车下一步）</p><p>然后你的密钥就会存在~/.ssh这个文件夹里，里面应该有两个文件：id_rsa和id_rsa.pub，等会我们讲到Github Pages时会用到它们。</p><h2 id="Hexo的安装和配置"><a href="#Hexo的安装和配置" class="headerlink" title="Hexo的安装和配置"></a>Hexo的安装和配置</h2><h3 id="什么是Hexo？"><a href="#什么是Hexo？" class="headerlink" title="什么是Hexo？"></a>什么是Hexo？</h3><p>Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown或其他渲染引擎解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="Hexo的安装"><a href="#Hexo的安装" class="headerlink" title="Hexo的安装"></a>Hexo的安装</h3><p>运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure></p><p>安装hexo。运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure></p><p>检查是否hexo安装好了，安装完成后，新建一个文件夹初始化自己的博客：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir Blog</span><br><span class="line">cd Blog</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure></p><p>然后运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>npm会自动安装你需要的组件，等待它完成即可。</p><h3 id="Hexo简单体验"><a href="#Hexo简单体验" class="headerlink" title="Hexo简单体验"></a>Hexo简单体验</h3><p>运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><p>然后点击终端中的链接 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 来预览你所搭建的博客。</p><p><img src="/hexo_github_blog/1.png" alt=""></p><p>现在Hexo在本地的配置差不多结束了，接下来说明如何将Hexo和Github Pages联系起来，也就是让你的博客可以通过网络访问。</p><h2 id="Github的配置"><a href="#Github的配置" class="headerlink" title="Github的配置"></a>Github的配置</h2><h3 id="什么是Github-Pages？"><a href="#什么是Github-Pages？" class="headerlink" title="什么是Github Pages？"></a>什么是Github Pages？</h3><p><img src="/hexo_github_blog/7.png" alt=""></p><p><a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a>是Github提供给Github用户的一个静态页面，可以用来展示你个人、组织或项目的页面。</p><pre><code>GitHub Pages is a static site hosting service designed to host your personal, organization, or project pages directly from a GitHub repository.</code></pre><p>当然，你可以利用它来搭建属于自己的博客。</p><h3 id="如何创建属于我的Github-Pages？"><a href="#如何创建属于我的Github-Pages？" class="headerlink" title="如何创建属于我的Github Pages？"></a>如何创建属于我的Github Pages？</h3><p>官方提供了简单的教程 <a href="https://pages.github.com/" target="_blank" rel="noopener">https://pages.github.com/</a></p><p>如果你对Github有所了解，你可以按照官方的教程创建，当然，你也可以按照我下面说的做：</p><p>首先，注册一个Github账号，不多说，然后点击主页右方的：</p><p><img src="/hexo_github_blog/2.png" alt=""></p><p>然后会出现这个页面，yourname请替换为你的github用户名：</p><p><img src="/hexo_github_blog/3.png" alt=""></p><p>这个yourname.github.io就是你博客的域名，然后应该会出现：</p><p><img src="/hexo_github_blog/4.png" alt=""></p><p>这就意味着你成功创建了属于你的repository。</p><p>然后点击右上角Settings：</p><p><img src="/hexo_github_blog/5.png" alt=""></p><p>点击SSH and GPG keys，再点击New SSH key，进入如下页面：</p><p><img src="/hexo_github_blog/6.png" alt=""></p><p>在终端运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p><p>复制那一长串像乱码的东西，将他们粘贴到刚才的Add new页面，添加新的SSH key。</p><p>Github方面的配置已经差不多了。</p><h2 id="博客的部署"><a href="#博客的部署" class="headerlink" title="博客的部署"></a>博客的部署</h2><p>回到刚才你Hexo初始化的博客那里，教程里为~/Blog。</p><p>终端进入该文件夹，然后运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>安装完成后，打开_config.yml文件，找到Deployment，按照如下进行修改，请将yourname替换为你的Github用户名：</p><pre><code>deploy:  type: git  repo: git@github.com:yourname/yourname.github.io.git  branch: master</code></pre><p>保存文件，然后在终端运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p><p>就可以将你的博客部署到Github page上去了，稍等片刻，在浏览器中访问yourname.github.io就可以看到你的博客了。</p><h2 id="如何编辑和发布博客"><a href="#如何编辑和发布博客" class="headerlink" title="如何编辑和发布博客"></a>如何编辑和发布博客</h2><p>进入你博客的本地文件夹，想新建一篇博客，运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new title</span><br></pre></td></tr></table></figure></p><p>然后你就可以在/source/_posts下面找到你的博客文件，文件格式为Markdown，利用Markdown编辑博客即可。</p><p>博客编写完成后，进行博客的生成和部署：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><p>然后稍等片刻，访问你的博客地址，你就可以看到你刚才写的博客了，当然你也可以在发布之前，运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><p>在本地预览博客发布后的页面。</p><p>更多细节，请访问<a href="https://hexo.io/zh-cn/docs/writing.html" target="_blank" rel="noopener">Hexo文档</a>。</p><h2 id="挑选一个Hexo主题"><a href="#挑选一个Hexo主题" class="headerlink" title="挑选一个Hexo主题"></a>挑选一个Hexo主题</h2><p>想让你的博客变得更好看？你可以访问<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方主题市场</a>或者从github上获取主题，我选择的主题是<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">Melody</a>，这个主题提供了详细的主题配置文档，你可以按照文档来配置属于你的博客。</p>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从今天开始博客生活！</title>
      <link href="/start_bolg_life/"/>
      <url>/start_bolg_life/</url>
      
        <content type="html"><![CDATA[<p>一直有想开个博客的想法，然而自己写博客又不会太频繁，每个月为vps花钱觉得不值得，于是就一直放置了。昨日偶然看到利用Github Pages可以免费搭建博客（虽然如果想要个性域名还是要花钱的），就网上找了找教程，搭了一个出来……</p><a id="more"></a><p>总共大概花了一天的时间？虽然大部分时间都花在找主题上了。</p><p>有了自己的博客，以后看书学习的时候有想法就可以写一写了，而我也认为自己只看书很容易忘，写成博客放到网上一方面可以加深自己的印象，另一方面如果看我博客的人能从中有什么收获，也算是件好事吧。</p><p>等几天把自己搭博客的过程分享一下，纪念一下自己的第一个博客，而且如果也有想搭博客的人，希望能对你有所帮助。</p><p>希望自己能坚持写博客，不断学习，就这样，我的博客生活就从今天开始了！</p>]]></content>
      
      
      <categories>
          
          <category> 日常随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
