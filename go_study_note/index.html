<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Go学习笔记"><meta name="keywords" content="Golang,笔记"><meta name="author" content="Crystalwindz,undefined"><meta name="copyright" content="Crystalwindz"><title>Go学习笔记 | Crystalwindz's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="站点概览">文章详情</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#语法"><span class="toc-text">语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口"><span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存"><span class="toc-text">内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工具"><span class="toc-text">工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信道"><span class="toc-text">信道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map"><span class="toc-text">map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#坑"><span class="toc-text">坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-text">其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defer相关"><span class="toc-text">defer相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Effective-Go"><span class="toc-text">Effective Go</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Go-Programming-Language"><span class="toc-text">The Go Programming Language</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s1.ax1x.com/2018/04/09/CFFVpQ.jpg"></div><div class="author-info__name text-center">Crystalwindz</div><div class="author-info__description text-center">Talk is cheap. Show me the code.</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">21</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">27</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">12</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://gentlezuo.github.io/" target="_blank">gentlezuo</a><a class="author-info-links__name text-center" href="https://1fishman.github.io/" target="_blank">1fishman</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s1.ax1x.com/2018/11/22/FPvENR.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Crystalwindz's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">Go学习笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Golang/">Golang</a><div class="post-meta-wordcount"><span>字数: </span><span class="word-count">2.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 7 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>for是Go中的while；</li>
<li>if可以在判断之前执行一条语句；</li>
<li>switch自动break，case无需为整数；</li>
<li>切片的cap就是切片能扩展的最大长度；</li>
<li>指针不能运算；</li>
<li>类型和函数不用先声明就能用；</li>
<li>Go里面没有隐式类型提升；</li>
<li>类型定义和类型方法必须在同一个包内；</li>
<li>.(type)类型选择必须和switch一起结合使用（泛型编程？）；</li>
<li><strong>无论是指针还是值，都可以直接通过 . 访问成员，Go自动(*p).x</strong>；</li>
<li><strong>类型方法也是，无论接受指针还是值，指针和值都可以直接调用，Go自动(*p).foo()或(&amp;a).foo()，这时的指针接受者可以理解为C++里的引用</strong>；</li>
<li>每定义一个常量，iota就递增1，iota从0开始；</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li><strong>接口指针永远无法满足接口</strong>；</li>
<li><strong>接口里存的永远是变量的具体类型，绝不可能是另一个接口类型，因此可以把接口类型和其他类型看做两种类型，接口是用来存其他类型的</strong>；</li>
<li><strong>实现接口时如果是指针类型，那么就只有类型指针满足接口，毕竟指针接口会更改原值</strong>；</li>
<li><strong>但实现接口时如果是值类型，那么类型和类型指针都满足接口，这时只需要传一个拷贝，那么是不是指针就无所谓了</strong>；</li>
<li>空接口interface{}可保存任意值；</li>
<li>接口类型可以内嵌其他接口，相当于把其他接口方法写在这里；</li>
</ul>
<a id="more"></a>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul>
<li>Go中函数形参都是传值的；</li>
<li>slice、map、chan是引用类型；</li>
<li>nil指针是可以调用方法的，不会导致空指针异常，毕竟没有解引用（C++里是因为要先解引用才能调用成员函数，换句话说就是this指针不能为空）；</li>
<li>但nil指针是不能访问成员的，这会导致解引用空指针SIGSEGV；</li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li>Go是静态编译的；</li>
<li>go install和go build的区别：从go help来看，go build会编译main包并将bin文件写到当前目录，如果编译的文件不是main包或是多个包，bulid只检查这些文件是否可编译，并不生成文件，并且build会忽略*_test.go文件，但在只编译一个包时可以指定-o强制build生成文件；go install会把二进制文件放在bin文件夹里，*.a文件放在pkg文件夹里；</li>
</ul>
<h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><ul>
<li><strong>信道上的发送操作总在对应的接收操作完成前发生</strong>；</li>
<li><strong>从无缓冲信道进行的接收，要发生在对该信道进行的发送完成之前</strong>；</li>
<li><strong>再解释一下上面两点，如果读一个ch，只有另一个go程对ch写了，读才能返回；如果写一个无缓冲ch，只有另一个go程对ch读了，写才能返回</strong>；</li>
<li><strong>就算r1监测到了w1，也不意味着r1之后的r2能检测到w0（应该是因为编译器调换了w之间的位置？）</strong>；</li>
<li><strong>nil chan永远不会准备好通信</strong>，这可以用在select里；</li>
<li>chan通过放置&lt;-的位置决定chan是只读还是只写还是双向；</li>
<li>Go程没有返回值，惯例是传入一个chan，通过这个chan发送返回值；</li>
</ul>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul>
<li>map不是线程安全的，不过Go1.9里新加了sync.Map；</li>
<li>容量为0的map和nil map是两个东西，nil map是不能添加元素的；</li>
</ul>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><ul>
<li>闭包和Go程一起使用时，当心<strong>不要让Go程共享一个变量</strong>，请传一个拷贝进去；</li>
<li><strong>string类型是不可变的</strong>，因此取s[i]的地址也是非法的；</li>
<li>接口内嵌和type alias时注意不要递归循环引用；</li>
<li>defer关闭句柄请按参数传入，函数体内直接用的话是引用，可能会在defer函数执行前被更改；</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>函数的最后一个参数如果是…T，这相当于[]T，说明可以用T类型的零个(nil)或多个参数调用函数；</li>
<li><strong>make([]int, 50, 100)和new([100]int)[0:50]是等价的</strong>；</li>
<li>type alias(Go 1.9)：使用type关键字时，如果是type A = int，那么A就是int的别名，这和type B int，定义了一个新类型B不一样；</li>
<li>假如有这样一个函数 func (t T) Foo(a int) int {}，那么T.Foo就是 func(t T, a int) int 这样一个函数，类似的如果是指针的话，就要(<em>T).Foo这样写，产生一个 func(t </em>T, a int) int 函数；</li>
</ul>
<h2 id="defer相关"><a href="#defer相关" class="headerlink" title="defer相关"></a>defer相关</h2><ul>
<li><a href="https://blog.csdn.net/Tybyqi/article/details/83827140" target="_blank" rel="noopener">defer实现原理剖析，写的相当不错</a></li>
<li>defer调用的函数的参数在defer语句时就已经确定；</li>
<li>defer后进先出；</li>
<li><strong>如果一个函数有命名返回值的话，那么在defer函数里是可以更改这个返回值的</strong>；</li>
<li>For instance, if the deferred function is a function literal and the surrounding function has named result parameters that are in scope within the literal, the deferred function may access and modify the result parameters before they are returned. If the deferred function has any return values, they are discarded when the function completes.</li>
</ul>
<h2 id="Effective-Go"><a href="#Effective-Go" class="headerlink" title="Effective Go"></a>Effective Go</h2><ul>
<li>只包含一个方法的接口以方法名加er命名；</li>
<li>可以返回局部变量的地址；</li>
<li>每当获取一个复合字面的地址时，都将为一个新的实例分配内存；</li>
<li>new和make：new分配一块内存并将内存<strong>置零</strong>，返回其指针；make只用于创建三种引用类型——slice、map、channel——并对其进行初始化；</li>
<li>实现Stringer接口当心递归；</li>
<li>func init()在main前设置一些初始状态，也可以检查一些东西；</li>
<li>如果一个类型只实现了一个接口，没有其他导出的方法，那么应该只导出这个接口，这能让代码更通用；</li>
<li>通过通信共享内存；</li>
<li>使用Context时，把它放在函数的第一个参数；</li>
<li>从其他包拷贝结构体时当心拷贝其内部的引用(切片等)；</li>
<li>var t []string 与 t:=[]string{}，前者是nil切片，后者是non-nil空切片，注意区分；</li>
<li>使用crypto/rand生成密钥；</li>
<li>error string应该是小写的一个短语，因为它通常用在别的句子里；</li>
<li>尽可能控制Go程生命周期；</li>
<li>分组import；</li>
<li>. import通常只在test中有用；</li>
<li>函数返回错误应该是最后一个返回值；</li>
<li><p>处理错误流请这样写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x, err := foo()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use x, normal code</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用后再定义接口，在接口的使用处定义，而不是接口的实现处；</p>
</li>
<li>方法接受者的名字应该是一个简短的缩写，不应该是this, self这种，并且接受者名字请在所有方法中保持一致；</li>
<li>传值或指针的场景：<ul>
<li>值：小类型、不需要更改的值、map、func、chan、不变的slice；</li>
<li>指针：大类型、需要更改的值、包含同步的值、选值或指针都差不多时就选指针；</li>
</ul>
</li>
<li>尽可能使用同步函数；</li>
<li>变量名尽可能短一点，声明距离使用越远就越应该有描述性；</li>
</ul>
<h2 id="The-Go-Programming-Language"><a href="#The-Go-Programming-Language" class="headerlink" title="The Go Programming Language"></a>The Go Programming Language</h2><ul>
<li>Go不需要加分号，但这不意味着Go没有分号。实际上是由编译器将特定符号后的换行符自动转换为分号的，这也是为什么左大括号必须和函数声明在同一行的原因。另外这也对Go代码换行有一定影响，比如：x + y，必须要在+后换行，在+前换行的话，编译器会在x后面添加分号，然后就编译错误了，参数列表最后可以加逗号也是这个原因；</li>
<li>map是哈希map，并且是随机哈希，每次range遍历顺序都不一致，这是为了防止利用哈希冲突的DOS攻击；</li>
<li>对象的(生命周期、分配区域)和(作用域、是否用var或new声明)无关，因为一个变量的生命周期只取决于是否可达，即使是局部变量，也可能因为有外部指针引用了它而逃逸，而就算是new的变量，只要它没逃逸也是可以分配在栈上的；</li>
<li>内存分配因为有了垃圾回收会好很多，但请考虑生命周期问题，比如不要把指向短生命周期对象的指针放在长生命周期对象中；</li>
<li>元组赋值，先对右边所有表达式求值，再统一更新左边变量；</li>
<li>类型转换错误只会发生在编译阶段；</li>
<li>包在解决依赖的前提下，按导入顺序初始化，每个包只初始化一次；</li>
<li>对于需要复杂初始化的全局变量，可以将初始化放在init函数中进行，也可以将初始化逻辑包装为一个匿名函数处理；</li>
<li>作用域是编译时的概念，生命周期是运行时的概念；</li>
<li><p>当心下面的坑，在这里，内部新声明了cwd变量，而全局cwd并未被正确初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cwd <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cwd, err := os.Getwd() <span class="comment">// <span class="doctag">NOTE:</span> wrong!</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"os.Getwd failed: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Working directory = %s"</span>, cwd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个函数返回的浮点数结果可能失败，最好用单独的标志报告失败；</p>
</li>
<li>常量可以是无类型的，无类型常量可以提供很高的精度(至少256位)，可以用于更多的表达式而无需显式类型转换；</li>
</ul>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/笔记/">笔记</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/socket_close_detail/"><span>从一道面试题入手——谈谈socket的关闭</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By Crystalwindz</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":110,"height":216,"hOffset":-12,"vOffset":-7},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script></body></html>